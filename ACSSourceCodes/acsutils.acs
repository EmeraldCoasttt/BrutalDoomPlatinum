/*
MIT License

Copyright (c) 2016-2017 Alexander Korshun and the ACSUtils contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

ACSUtils uses code from ACS-X:	
	
	Copyright Ben Moir 2016
	Distributed under the Boost Software License, Version 1.0.

	Boost Software License - Version 1.0 - August 17th, 2003

	Permission is hereby granted, free of charge, to any person or organization
	obtaining a copy of the software and accompanying documentation covered by
	this license (the "Software") to use, reproduce, display, distribute,
	execute, and transmit the Software, and to prepare derivative works of the
	Software, and to permit third-parties to whom the Software is furnished to
	do so, all subject to the following:

	The copyright notices in the Software and this entire statement, including
	the above license grant, this restriction and the following disclaimer,
	must be included in all copies of the Software, in whole or in part, and
	all derivative works of the Software, unless such copies or derivative
	works are solely in the form of machine-executable object code generated by
	a source language processor.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
	SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
	FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
	ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	DEALINGS IN THE SOFTWARE.
*/
#library "acsutils"
#nocompact

// ZDoom does not allow to use more than 128 map variables in a single library.
// To reduce the amount of map variables ACSUtils use, all simple globals
// have been put into an array.

#include "zcommon.acs"

#libdefine ACSUTILS_VERSION_MAJOR 1
#libdefine ACSUTILS_VERSION_MINOR 8
#libdefine ACSUTILS_VERSION_PATCH 2

function str ACSUtilsVersion(void)
{
	return StrParam(
		d:ACSUTILS_VERSION_MAJOR, s:".",
		d:ACSUTILS_VERSION_MINOR, s:".",
		d:ACSUTILS_VERSION_PATCH
	);
}

// Multiple return values.
int r1, r2, r3, r4, r5, r6, r7, r8;

#libdefine HUDTIC 0.03
#libdefine HUD_STAYTIME_FOREVER (-1)

#libdefine HUD_BLENDSTYLE_NORMAL 0
#libdefine HUD_BLENDSTYLE_ADDITIVE 1

#libdefine HUD_ALIGN_CENTER 0
#libdefine HUD_ALIGN_LEFT 1
#libdefine HUD_ALIGN_RIGHT 2
#libdefine HUD_ALIGN_TOP 1
#libdefine HUD_ALIGN_BOTTOM 2

#libdefine HUD_PROJECTION_AUTO 0
#libdefine HUD_PROJECTION_3D 1
#libdefine HUD_PROJECTION_YSHEARING 2



int ACSUtils_Ints[55] = {
	240.0, // CursorY
	false, // R_TextColorIsString
	480.0, // CursorAreaHeight
	CR_UNTRANSLATED, // R_TextColor
	-1, // CachedPort
	0.0, // R_AppearTime
	HUD_STAYTIME_FOREVER, // R_StayTime
	1.0, // CursorSpeedY
	false, // CursorWrapX
	0.0, // R3D_CameraY
	false, // R_TextWordWrap
	0.0, // R3D_CameraPitch
	0.0, // R3D_2DOffsetX
	HUD_ALIGN_CENTER, // R_AlignX
	0, // R_RotatedX
	0.0, // R3D_Y
	320.0, // CursorPrevX
	HUD_PROJECTION_AUTO, // R3D_ProjectionMode
	0.0, // R_Y
	0.0, // R3D_CameraX
	0.0, // R3D_Z
	0.0, // R3D_2DOffsetY
	0, // R_RotatedZ
	640.0, // R_BaseWidth
	true, // R_ShowIn3DView
	1.0, // R_Alpha
	false, // R_CenterText
	HUDMSG_LAYER_OVERHUD, // R_Layer
	0.0, // R3D_CameraAngle
	0, // CursorMotionX
	1.0, // R_IScaleX
	1.0, // CursorSpeedX
	0.0, // R3D_X
	false, // R_LogMessage
	true, // R_ShowOnOverlayAutomap
	320.0, // CursorX
	0, // HudStateStackTop
	false, // R_ShowToEveryone
	0, // CursorMotionY
	HUD_BLENDSTYLE_NORMAL, // R_BlendStyle
	0.0, // R3D_CameraZ
	0.0, // R_X
	true, // R3D_AutoDistanceScale
	false, // CursorWrapY
	0, // R_RotatedY
	false, // R_ExcludeStatusBar
	480.0, // R_BaseHeight
	240.0, // CursorPrevY
	0.0, // R_DisappearTime
	HUD_ALIGN_CENTER, // R_AlignY
	true, // R_ShowOnFullAutomap
	1.0, // R_IScaleY
	false, // R_Is3DPoint
	640.0, // CursorAreaWidth
	false, // R_TextTypeOn
};

str ACSUtils_Strings[1] = {
	"SMALLFONT", // R_TextFont
};

#define ACSUTILS_ERROR_PROGRAM 0
#define ACSUTILS_ERROR_MAPPING 1
#define ACSUTILS_ERROR_LIMIT 2

function void ACSUtils_ProgramError(str message)
{
	ACSUtils_ErrorHandler(ACSUTILS_ERROR_PROGRAM, message);
}

function void ACSUtils_LimitError(str message)
{
	ACSUtils_ErrorHandler(ACSUTILS_ERROR_LIMIT, message);
}

function void ACSUtils_ErrorHandler(int type, str message)
{
	str text = "";
	if (IsServer() != IsClient())
	{
		if (IsServer())
			text = "[\cgserverside\c-] ";
		else
			text = "[\cdclientside\c-] ";
	}
	
	text = StrParam(s:text, d:Timer(), s:" ACSUtils error: ", s:message);
	if (!IsClient())
		Log(s:text);

	if (GetCVar("acsutils_noerrors"))
		return;

	printbold(s:text);
}
#libdefine INT_MAX 0x7fffffff
#libdefine INT_MIN 0x80000000
#libdefine FIXED_MAX (0x7fffffff)
#libdefine FIXED_MIN (0x80000000)
#libdefine USHORT_MAX 65535
#libdefine SHORT_MAX 32767
#libdefine SHORT_MIN -32768
#libdefine UBYTE_MAX 255
#libdefine SBYTE_MAX 127
#libdefine SBYTE_MIN -128

#libdefine PI 3.1415926535897932384626433832795
#libdefine TAU 6.2831853071795864769252867665590
#libdefine SQRT_2 1.41421356237
#libdefine MATH_E 2.7182818284590452353602874713526624977572470937
#libdefine LOG2_E 1.44269504089
#libdefine LOG2_10 3.32192809489

// Generic functions.

function int min(int a, int b)
{
	if (a < b)
		return a;
	return b;
}

function int max(int a, int b)
{
	if (a > b)
		return a;
	return b;
}

function int clamp(int x, int a, int b)
{
	if (x > b)
		return b;
	if (x < a)
		return a;
	return x;
}	

function int sgn(int x)
{
	if (x > 0)
		return 1;
	if (x < 0)
		return -1;
	return 0;
}

function int abs(int x)
{
	if (x > 0)
		return x;
	return -x;
}

// From commonFuncs.h by Ijon Tichy.
function int middle(int x, int y, int z)
{
    if ((x < z) && (y < z)) { return max(x, y); }
    return max(min(x, y), z);
}

function int cmp(int a, int b)
{
	if (a > b)
		return 1;
	if (a < b)
		return -1;
	return 0;
}

function int mod(int a, int b)
{
	if (a < 0)
	{
		int rem = a % b;
		if (rem != 0)
			return b + (a % b);
		return 0;
	}
	
	return a % b;
}

function int cond(bool x, int whentrue, int whenfalse)
{
	if (x)
		return whentrue;
	return whenfalse;
}

function int condTrue(int x, int whentrue)
{
	if (x)
		return whentrue;
	return x;
}

function int condFalse(int x, int whenfalse)
{
	if (x)
		return x;
	return whenfalse;
}

// Rounding.

function int fract(int x)
{
	return x - trunc(x);
}

function int trunc(int x)
{
	if (x > 0.0)
		return floor(x);
	return ceil(x);
}

/* ZDOOM DEFINES ITS OWN VERSIONS OF floor, ceil AND round THAT SILENTLY RETURN 0 IN ZANDRONUM, PLEASE REMOVE THESE FUNCTIONS FROM FROM zspecial.acs OR RENAME THE ACSUTILS OR ZDOOM FUNCTIONS TO SOMETHING ELSE. */ function int flooor(int x)
{
	return ((x) & 0xffff0000);
}

/* ZDOOM DEFINES ITS OWN VERSIONS OF floor, ceil AND round THAT SILENTLY RETURN 0 IN ZANDRONUM, PLEASE REMOVE THESE FUNCTIONS FROM FROM zspecial.acs OR RENAME THE ACSUTILS OR ZDOOM FUNCTIONS TO SOMETHING ELSE. */function int ceill(int x)
{
	return (((x) - 1) & 0xffff0000) + 1.0;
}

/* ZDOOM DEFINES ITS OWN VERSIONS OF floor, ceil AND round THAT SILENTLY RETURN 0 IN ZANDRONUM, PLEASE REMOVE THESE FUNCTIONS FROM FROM zspecial.acs OR RENAME THE ACSUTILS OR ZDOOM FUNCTIONS TO SOMETHING ELSE. */ function int roundd(int x)
{
	return ((x + 0.5) & 0xffff0000);
}

function int itrunc(int x)
{
	if (x > 0.0)
		return ifloor(x);
	return iceil(x);
}

function int ifloor(int x)
{
	return (x)>>16;
}

function int iceil(int x)
{
	return ((x) - 1 >> 16) + 1;
}

function int iround(int x)
{
	return (x + 0.5) >> 16;
}


// Numerical algorithms.

function int AngleDiff(int a, int b)
{
	a = mod(a, 1.0);
	b = mod(b, 1.0);
	int diff = b - a;

	if (diff > 0.5)
		return diff - 1.0;
	else if (diff < -0.5)
		return diff + 1.0;
	return diff;
}


function int ipow(int x, int y)
{
    int n = 1;
    while (y-- > 0)
		n *= x;
    return n;
}

function int fpow(int x_, int y_)
{
	int x = x_;
	int y = y_;
	int n = 1.0;
	if (y > 0)
	{
		while (y-- > 0)
			n = FixedMul(n, x);
		return n;
	}
	
	while (y++ < 0)
		n = FixedDiv(n, x);
	return n;
}

function int lerp(int a, int b, int alpha)
{
	return FixedMul(a, 1.0 - alpha) + FixedMul(b, alpha);
}

// From commonFuncs.h by Ijon Tichy.
function int gcf(int a, int b)
{
    int c;
    while (1)
    {
        if (b == 0) { return a; }
        c = a % b;
        a = b;
        b = c;
    }
    
    return -1;
}

// By TechnoDoomed1
// int IntDiv(int a, int b)
function int IntDiv (int a_, int b_) {
    int a = a_;
	int b = b_;
	int quotient = 0, current_fraction = 1.0;

    // Only works when the ratio is less than 32767 = 2^15 - 1.
    // Otherwise return 0.

    if ((abs(a) / abs(b)) > 32767) {
        return 0.0;
    }

    // Performs the same algorithm as hand division, but working with powers of 2 instead of 10.
    // This is done until we reach the maximum allowed precision, which is 1 (=2^-16 in int point).

    while (current_fraction > 1) {
        quotient += (a / b) * current_fraction;
        a = (a % b) * 2;
        current_fraction /= 2;
    }

    return (quotient);
}

// int, int swap(int a, int b)
function void swap(int a, int b)
{
	r1 = b;
	r2 = a;
}

// Bit math.

function int getbit(int x, int n)
{
	return x & (1 << n);
}

function int clrbit(int p, int n)
{
	return p & ~(1 << n);
}

function int setbit(int p, int n)
{
	return p | ~(1 << n);
}

function int tglbit(int p, int n)
{
	return p ^ (1 << n);
}

function bool notflag(int flags, int flag)
{
	return !(flags & flag);
}

function bool randbool(void)
{
	return (Random(0, 1));
}

function int randint(void)
{
	return Random(INT_MIN, INT_MAX);
}

// From commonFuncs.h by Ijon Tichy.
function int randsign(void)
{
	return 2 * Random(0, 1) - 1;
}

function int RandomPick2(int v0, int v1)
{
	if (Random(0, 1))
		return v0;
	return v1;
}

function int RandomPick3(int v0, int v1, int v2)
{
	int x = Random(0, 2);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	}

	return v2;
}

function int RandomPick4(int v0, int v1, int v2, int v3)
{
	int x = Random(0, 3);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	}

	return v3;
}

function int RandomPick5(int v0, int v1, int v2, int v3, int v4)
{
	int x = Random(0, 4);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	}

	return v4;
}

function int RandomPick6(int v0, int v1, int v2, int v3, int v4, int v5)
{
	int x = Random(0, 5);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	}

	return v5;
}

function int RandomPick7(int v0, int v1, int v2, int v3, int v4, int v5, int v6)
{
	int x = Random(0, 6);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	case 5: return v5;
	}

	return v6;
}

function int RandomPick8(int v0, int v1, int v2, int v3, int v4, int v5, int v6, int v7)
{
	int x = Random(0, 7);
	switch (x)
	{
	case 0: return v0;
	case 1: return v1;
	case 2: return v2;
	case 3: return v3;
	case 4: return v4;
	case 5: return v5;
	case 6: return v6;
	}

	return v7;
}

function int npo2(int v)
{
	v--;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;
	return v;
}

function int getNumDigits(int base, int number)
{
	int digits = 0;
	while (number)
	{
		digits++;
		number /= base;
	}
	return digits;
}

function int flag2index(int x)
{
	return getNumDigits(2, x) - 1;
}


// Logarithms.

// All logaritm functions written by TechnoDoomed1 unless stated otherwise

function int log2 (int x_) {
    int x = x_;
	
	// We calculate the integral and decimal parts of the bit logarithm of x.
    int integer_part = 0, decimal_part = 0;

    // The integral part is how many times we can divide by 2 until we reach a number in the range [1, 2).
    // If the number is on the range (0, 1) then we multiply by 2 until we reach a number in the range [1, 2).
    while (x < 1.0) {
        -- integer_part;
        x *= 2;
    }
    while (x >= 2.0) {
        ++ integer_part;
        x /= 2;
    }

    // Then, we square the number each time to get the next relevant byte, until we reach max precision allowed.
    // WHY? Because if 2^d = y, then (2^d)^2 = 2^(2d) = y^2, where d is the decimal part.
    //-----------------------------------------------------------------------------------------------------------------
    // Let's start with the fraction 1/2, and go downwards until we reach the max precision for a int-point number,
    // which is 1 (since it occupies the right side of the byte, it really represents 2^-16).

    int current_fraction = 0.5;

    while (current_fraction > 1) {
        x = FixedMul(x, x);
        if (x >= 2.0) {
            decimal_part += current_fraction;
            x /= 2;
        }

        current_fraction /= 2;
    }

    // We can finally return the number as the integral part (shifted 16 bytes to the left, to be on the corresponding
    // integral part of the int-point number) plus the decimal part, which is the sum of all the fractions of 2 that
    // correspond to the solution of 2^d = y.

    return ((integer_part << 16) + decimal_part);
}

function int ilog2 (int x_) {
    int x = x_;
	
	// We calculate the integral and decimal parts of the bit logarithm of x.
    int integer_part = 0, decimal_part = 0;

    // The integral part is how many times we can divide by 2 until we reach a number lower than 2.
    // We lose precision by not keeping the fractional part until that part fits perfectly in a int number variable.
    while (x >= 32768) {
        ++ integer_part;
        x /= 2;
    }

    x <<= 16;

    while (x >= 2.0) {
        ++ integer_part;
        x /= 2;
    }

    // Then, we square the number each time to get the next relevant byte, until we reach max precision allowed.
    // WHY? Because if 2^d = y, then (2^d)^2 = 2^(2d) = y^2, where d is the decimal part.
    //-----------------------------------------------------------------------------------------------------------------
    // Let's start with the fraction 1/2, and go downwards until we reach the max precision for a int-point number,
    // which is 1 (since it occupies the right side of the byte, it really represents 2^-16).

    int current_fraction = 0.5;

    while (current_fraction > 1) {
        x = FixedMul(x, x);
        if (x >= 2.0) {
            decimal_part += current_fraction;
            x /= 2;
        }

        current_fraction /= 2;
    }

    // We can finally return the number as the integral part (shifted 16 bytes to the left, to be on the corresponding
    // integral part of the int-point number) plus the decimal part, which is the sum of all the fractions of 2 that
    // correspond to the solution of 2^d = y.

    return ((integer_part << 16) + decimal_part);
}


function int ln (int x) {
    // This calculates the natural logarithm of a number using the property that:   ln(x) = log_2(x) / log_2(e)
    // This is done because calculating the log_2 of a number is far easier, specially with int-point arithmetics. 

    return FixedDiv(log2(x), LOG2_E);
}

// By Korshun.
function int iln (int x) {
	return FixedDiv(ilog2(x), LOG2_E);
}

// By Korshun.
function int log10 (int x) {
	return FixedDiv(log2(x), LOG2_10);
}

// By Korshun.
function int ilog10 (int x) {
	return FixedDiv(ilog2(x), LOG2_10);
}

function int logb (int x, int base) {
    // This calculates the logarithm in any base > 1.0, by using the property that:   log_b(x) = log_2(x) / log_2(b)
    // Otherwise, returns 0.

    if (base > 1.0)
        return FixedDiv(log2(x), log2(base));
   
    return 0.0;
}

// By Korshun.
function int ilogb (int x, int base) {
    // This calculates the logarithm in any base > 1.0, by using the property that:   log_b(x) = log_2(x) / log_2(b)
    // Otherwise, returns 0.

    if (base > 1.0)
        return FixedDiv(ilog2(x), log2(base));
   
    return 0.0;
}

// Trigonometry.

function int tan(int x)
{
	return FixedDiv(sin(x), cos(x));
}

function int cot(int x)
{
	return FixedDiv(cos(x), sin(x));
}

function int sec(int x)
{
	return FixedDiv(1.0, sin(x));
}

function int cosec(int x)
{
	return FixedDiv(1.0, cos(x));
}

function int atan(int x)
{
    return VectorAngle(1.0, x);
}

function int asin(int x)
{
	return atan(FixedDiv(x, FixedSqrt(1.0 - FixedMul(x, x))));
}

function int acos(int x)
{
	return ((2) * (atan(FixedSqrt(FixedDiv(1.0 - x, 1.0 + x)))));
}

function int acot(int x)
{
 	return 0.25 - atan(x);
}

function int asec(int x)
{
	return acos(FixedDiv(1.0, x));
}

function int acosec(int x)
{
	 return asin(FixedDiv(1.0, x));
}

// Vectors.

// int, int RotateVector(int x, int y, int angle);
function void RotateVector(int x, int y, int angle)
{
	// Rotate around Z axis.
	int s = sin(angle);
	int c = cos(angle);
	r1 = FixedMul(x, c) - FixedMul(y, s);
	r2 = FixedMul(x, s) + FixedMul(y, c);
}

// int, int RotateVectorCS(int x, int y, int c, int s);
function void RotateVectorCS(int x, int y, int c, int s)
{
	// Rotate around Z axis.
	r1 = FixedMul(x, c) - FixedMul(y, s);
	r2 = FixedMul(x, s) + FixedMul(y, c);
}

// int, int RotatePoint(int x, int y, int originX, int originY, int angle)
function void RotatePoint(int x, int y, int originX, int originY, int angle)
{
	x -= originX;
	y -= originY;
	RotateVector(x, y, angle);
	r1 += originX;
	r2 += originY;
}

// int, int VectorToAngles(int x, int y, int z)
function void VectorToAngles(int x, int y, int z)
{
	int xy = VectorLength(x, y);
		
	r1 = VectorAngle(x, y);
	r2 = VectorAngle(xy, z);
}

// int, int, int AnglesToVector(int angle, int pitch)
function void AnglesToVector(int angle, int pitch)
{
	int cos_pitch = cos(pitch);
	r1 = FixedMul(cos_pitch, cos(angle));
    r2 = FixedMul(cos_pitch, sin(angle));
    r3 = sin(pitch);
}

function int VectorLength3D(int x, int y, int z)
{
	 return VectorLength(VectorLength(x, y), z);
}

function int SqVectorLength(int x, int y)
{
	return FixedMul(x, x) + FixedMul(y, y);
}

function int SqVectorLength3D(int x, int y, int z)
{
	return FixedMul(x, x) + FixedMul(y, y) + FixedMul(z, z);
}

function int dot2(int x1, int y1, int x2, int y2)
{
	return FixedMul(x1, x2) + FixedMul(y1, y2);
}

function int dot3(int x1, int y1, int z1, int x2, int y2, int z2)
{
	return FixedMul(x1, x2) + FixedMul(y1, y2) + FixedMul(z1, z2);
}

function void normalize2d(int x, int y)
{
	int l = VectorLength(x, y);
	r1 = FixedDiv(x, l);
	r2 = FixedDiv(y, l);
}

function void normalize3d(int x, int y, int z)
{
	int l = VectorLength3D(x, y, z);
	r1 = FixedDiv(x, l);
	r2 = FixedDiv(y, l);
	r3 = FixedDiv(z, l);
}

#libdefine COLORCODE 28

#define ACSUTILS_ISALNUM 1<<0
#define ACSUTILS_ISALPHA 1<<1
#define ACSUTILS_ISBLANK 1<<2
#define ACSUTILS_ISCNTRL 1<<3
#define ACSUTILS_ISDIGIT 1<<4
#define ACSUTILS_ISGRAPH 1<<5
#define ACSUTILS_ISLOWER 1<<6
#define ACSUTILS_ISPRINT 1<<7
#define ACSUTILS_ISPUNCT 1<<8
#define ACSUTILS_ISSPACE 1<<9
#define ACSUTILS_ISUPPER 1<<10
#define ACSUTILS_ISXDIGIT 1<<11


int ACSUtils_AsciiTypes[128] =
{
ACSUTILS_ISCNTRL, // NUL
ACSUTILS_ISCNTRL, // SOH
ACSUTILS_ISCNTRL, // STX
ACSUTILS_ISCNTRL, // ETX
ACSUTILS_ISCNTRL, // EOT
ACSUTILS_ISCNTRL, // ENQ
ACSUTILS_ISCNTRL, // ACK
ACSUTILS_ISCNTRL, // BEL
ACSUTILS_ISCNTRL, // BS
ACSUTILS_ISBLANK | ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // TAB
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // LF
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // VT
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // FF
ACSUTILS_ISCNTRL | ACSUTILS_ISSPACE, // CR
ACSUTILS_ISCNTRL, // SO
ACSUTILS_ISCNTRL, // SI
ACSUTILS_ISCNTRL, // DLE
ACSUTILS_ISCNTRL, // DC1
ACSUTILS_ISCNTRL, // DC2
ACSUTILS_ISCNTRL, // DC3
ACSUTILS_ISCNTRL, // DC4
ACSUTILS_ISCNTRL, // NAK
ACSUTILS_ISCNTRL, // SYN
ACSUTILS_ISCNTRL, // ETB
ACSUTILS_ISCNTRL, // CAN
ACSUTILS_ISCNTRL, // EM
ACSUTILS_ISCNTRL, // SUB
ACSUTILS_ISCNTRL, // ESC
ACSUTILS_ISCNTRL, // FS (COLORCODE)
ACSUTILS_ISCNTRL, // GS
ACSUTILS_ISCNTRL, // RS
ACSUTILS_ISCNTRL, // US
ACSUTILS_ISBLANK | ACSUTILS_ISPRINT | ACSUTILS_ISSPACE, // Space
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // !
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // "
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // #
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // $
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // %
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // &
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // '
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // (
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // )
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // *
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // +
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ,
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // -
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // .
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // /
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 0
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 1
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 2
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 3
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 4
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 5
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 6
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 7
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 8
ACSUTILS_ISALNUM | ACSUTILS_ISDIGIT | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // 9
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // :
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ;
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // <
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // =
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // >
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ?
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // @
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // A
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // B
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // C
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // D
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // E
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER | ACSUTILS_ISXDIGIT, // F
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // G
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // H
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // I
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // J
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // K
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // L
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // M
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // N
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // O
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // P
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // Q
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // R
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // S
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // T
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // U
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // V
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // W
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // X
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // Y
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISUPPER, // Z
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // [
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // \
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ]
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ^
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // _
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // `
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // a
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // b
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // c
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // d
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // e
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT | ACSUTILS_ISXDIGIT, // f
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // g
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // h
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // i
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // j
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // k
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // l
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // m
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // n
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // o
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // p
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // q
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // r
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // s
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // t
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // u
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // v
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // w
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // x
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // y
ACSUTILS_ISALNUM | ACSUTILS_ISALPHA | ACSUTILS_ISGRAPH | ACSUTILS_ISLOWER | ACSUTILS_ISPRINT, // z
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // {
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // |
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // }
ACSUTILS_ISGRAPH | ACSUTILS_ISPRINT | ACSUTILS_ISPUNCT, // ~
ACSUTILS_ISCNTRL, // DEL
};

function bool isalnum(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISALNUM);
}

function bool isalpha(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISALPHA);
}

function bool isblank(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISBLANK);
}

function bool iscntrl(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISCNTRL);
}

function bool isdigit(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISDIGIT);
}

function bool isgraph(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISGRAPH);
}

function bool islower(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISLOWER);
}

function bool isprint(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISPRINT);
}

function bool ispunct(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISPUNCT);
}

function bool isspace(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISSPACE);
}

function bool isupper(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISUPPER);
}

function bool isxdigit(int c)
{
	return (ACSUtils_AsciiTypes[c] & ACSUTILS_ISXDIGIT);
}

function bool isascii(int c)
{
	return c >= 0 && c < 128;
}

function int toupper(int c)
{
	if (islower(c))
		return c - 32;
	return c;
}

function int tolower(int c)
{
	if (isupper(c))
		return c + 32;
	return c;
}


// String versions
function bool StrIsAlNum(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isalnum(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsAlpha(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isalpha(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsBlank(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isblank(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsCntrl(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!iscntrl(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsDigit(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isdigit(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsGraph(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isgraph(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsLower(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!islower(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsPrint(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isprint(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsSpace(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isspace(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsUpper(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isupper(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsXDigit(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		if (!isxdigit(GetChar(s, i)))
			return false;
			
	return true;
}

function bool StrIsAscii(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
	{
		int char = GetChar(s, i);
		if (char < 0 || char > 127)
			return false;
	}
	return true;
}

// Case conversion.

function str StrToLower(str s)
{
	str result = "";
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		result = StrParam(s:result, c:tolower(GetChar(s, i)));
		
	return result;
}

function str StrToUpper(str s)
{
	str result = "";
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		result = StrParam(s:result, c:toupper(GetChar(s, i)));
		
	return result;
}

// Basic
function bool StrIsEmpty(str s)
{
	if (!GetChar(s, 0))
		return true;
	return false;
}


// StrAdd
function str StrAdd(str a, str b)
{
	return StrParam(s:a, s:b);
}

function str StrAddInt(str a, int b)
{
	return StrParam(s:a, d:b);
}

function str StrAddChar(str a, int b)
{
	return StrParam(s:a, c:b);
}

function str StrAddFixed(str a, int b)
{
	return StrParam(s:a, f:b);
}

// StrEquals
function bool StrEquals(str a, str b)
{
    return StrCmp(a, b) == 0;
}	

function bool StrIEquals(str a, str b)
{
	return StrICmp(a, b) == 0;
}

function bool StrEqualsAt(str s, int where, str what)
{
	int len = StrLen(what);
	if (where + len > StrLen(s))
		return false;
	
	return StrEquals(StrMid(s, where, len), what);
}

function bool StrIEqualsAt(str s, int where, str what)
{
	int len = StrLen(what);
	if (where + len > StrLen(s))
		return false;
	
	return StrIEquals(StrMid(s, where, len), what);
}

function bool StrStartsWith(str s, str sub)
{
	return StrEqualsAt(s, 0, sub);
}

function bool StrStartsWithI(str s, str sub)
{
	return StrIEqualsAt(s, 0, sub);
}

function bool StrEndsWith(str s, str what)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);

	if (len1 < len2)
		return false;
	return StrEqualsAt(s, len1 - len2, what);
}

function bool StrEndsWithI(str s, str what)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);

	if (len1 < len2)
		return false;
	return StrIEqualsAt(s, len1 - len2, what);
}

// StrFind
function int StrFind(str s, str what)
{
	return StrFindFrom(s, what, 0);
}

function int StrFindI(str s, str what)
{
	return StrFindFromI(s, what, 0);
}

function int StrRFind(str s, str what)
{
	return StrRFindFrom(s, what, StrLen(s) - 1);
}

function int StrRFindI(str s, str what)
{
	return StrRFindFromI(s, what, StrLen(s) - 1);
}

function int StrFindFrom(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i <= len; i++)
	{
		if (StrEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

function int StrFindFromI(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i <= len; i++)
	{
		if (StrIEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

function int StrRFindFrom(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i >= 0; i--)
	{
		if (StrEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

function int StrRFindFromI(str s, str what, int start)
{
	int len = StrLen(s) - StrLen(what);
	for (int i = start; i >= 0; i--)
	{
		if (StrIEqualsAt(s, i, what))
			return i;
	}
	
	return -1;
}

// StrRemove
function str StrRemove(str s, str what)
{
	return StrReplace(s, what, "");
}

function str StrRemoveI(str s, str what)
{
	return StrReplaceI(s, what, "");
}

function str StrRemoveFirst(str s, str what)
{
	return StrRemoveFirstFrom(s, what, 0);
}

function str StrRemoveFirstI(str s, str what)
{
	return StrRemoveFirstFromI(s, what, 0);
}

function str StrRemoveLast(str s, str what)
{
	return StrRemoveLastFrom(s, what, StrLen(s) - 1);
}

function str StrRemoveLastI(str s, str what)
{
	return StrRemoveLastFromI(s, what, StrLen(s) - 1);
}

function str StrRemoveFirstFrom(str s, str what, int start)
{
	int pos = StrFindFrom(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

function str StrRemoveFirstFromI(str s, str what, int start)
{
	int pos = StrFindFromI(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

function str StrRemoveLastFrom(str s, str what, int start)
{
	int pos = StrRFindFrom(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

function str StrRemoveLastFromI(str s, str what, int start)
{
	int pos = StrRFindFromI(s, what, start);
	if (pos != -1)
		return StrCut(s, pos, StrLen(what));
	return s;
}

// StrReplace
function str StrReplace(str s, str what, str with)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);
	int start = 0;
	int end = 0;
	str result = "";

	while (true)
	{
		end = StrFindFrom(s, what, start);
		if (end == -1)
		{
			result = StrParam(s:result, s:StrSlice(s, start, end));
			break;
		}

		result = StrParam(s:result, s:StrSlice(s, start, end), s:with);
		start = end + len2;
	}
	
	return result;
}

function str StrReplaceI(str s, str what, str with)
{
	int len1 = StrLen(s);
	int len2 = StrLen(what);
	int start = 0;
	int end = 0;
	str result = "";

	while (true)
	{
		end = StrFindFromI(s, what, start);
		if (end == -1)
		{
			result = StrParam(s:result, s:StrSlice(s, start, end));
			break;
		}

		result = StrParam(s:result, s:StrSlice(s, start, end), s:with);
		start = end + len2;
	}
	
	return result;
}

function str StrReplaceFirst(str s, str what, str with)
{
	return StrReplaceFirstFrom(s, what, with, 0);
}

function str StrReplaceFirstI(str s, str what, str with)
{
	return StrReplaceFirstFromI(s, what, with, 0);
}

function str StrReplaceLast(str s, str what, str with)
{
	return StrReplaceLastFrom(s, what, with, StrLen(s) - 1);
}

function str StrReplaceLastI(str s, str what, str with)
{
	return StrReplaceLastFromI(s, what, with, StrLen(s) - 1);
}

function str StrReplaceFirstFrom(str s, str what, str with, int start)
{
	int pos = StrFind(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

function str StrReplaceFirstFromI(str s, str what, str with, int start)
{
	int pos = StrFindI(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

function str StrReplaceLastFrom(str s, str what, str with, int start)
{
	int pos = StrRFind(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

function str StrReplaceLastFromI(str s, str what, str with, int start)
{
	int pos = StrRFindI(s, what);
	if (pos != -1)
		return StrInsert(StrCut(s, pos, StrLen(what)), pos, with);
	return s;
}

// Misc
function str LeftPad(str s, int c, int size)
{
	int len = StrLen(s);
	if (len >= size)
		return s;
		
	int diff = size - len;
	str pad = "";
	for (int i = 0; i < diff; i++)
		pad = StrParam(s:pad, c:c);
		
	return StrParam(s:pad, s:s);
}

function str RightPad(str s, int c, int size)
{
	int len = StrLen(s);
	if (len >= size)
		return s;
		
	int diff = size - len;
	str pad = "";
	for (int i = 0; i < diff; i++)
		pad = StrParam(s:pad, c:c);
		
	return StrParam(s:s, s:pad);
}

function str StrCapitalize(str s)
{
	if (StrLen(s) == 0)
		return "";

	str result = StrParam(c:toupper(GetChar(s, 0)));
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
		result = StrParam(s:result, c:tolower(GetChar(s, i)));

	return result;
}

function bool StrContains(str s, str what)
{
	return StrFind(s, what) >= 0;
}

function bool StrContainsI(str s, str what)
{
	return StrFindI(s, what) >= 0;
}

function str StrCut(str s, int start, int length)
{
	return StrParam(s:StrLeft(s, start), s:StrRightFrom(s, start + length));
}

function str StrCutRange(str s, int start, int end)
{
	return StrParam(s:StrLeft(s, start), s:StrRightFrom(s, end));
}

function str StrInsert(str s, int where, str what)
{
	return StrParam(s:StrLeft(s, where), s:what, s:StrRightFrom(s, where));
}

function str StrSlice(str s, int start, int end)
{
	return StrMid(s, start, end - start);
}

function void StrSplit(str s, str separator)
{
	int pos = StrFind(s, separator);
	if (pos != -1)
	{
		r1 = StrLeft(s, pos);
		r2 = StrRightFrom(s, pos + StrLen(separator));
	}
	else
	{
		r1 = s;
		r2 = "";
	}
}

function void StrSplitI(str s, str separator)
{
	int pos = StrFindI(s, separator);
	if (pos != -1)
	{
		r1 = StrLeft(s, pos);
		r2 = StrRightFrom(s, pos + StrLen(separator));
	}
	else
	{
		r1 = s;
		r2 = "";
	}
}

function str StrRightFrom(str s, int from)
{
	return StrRight(s, StrLen(s) - from);
}

function str StrRepeat(str s, int n)
{
	str result = "";
	for (int i = 0; i < n; i++)
		result = StrAdd(result, s);
	return result;
}

function str StrReverse(str s)
{
	str tempstr = "";
	for(int i = StrLen(s)-1; i >= 0; i--)
		tempstr = StrParam(s:tempstr, c:GetChar(s, i));
	return tempstr;
}

// Color codes.
function bool IsColorCodeChar(int c)
{
	return (c >= 'a' && c <= 'v')
		|| c == '-'
		|| c == '+'
		|| c == '*'
		|| c == '!';
}

function int SkipColorCodeAt(str s, int i)
{
	if (GetChar(s, i) == COLORCODE)
	{
		i++;
	}
	else
	{
		return i;
	}
	
	if (GetChar(s, i) == '[')
	{
		int len = StrLen(s);
		for (; i < len; i++)
		{
			if (GetChar(s, i) == ']')
			{
				i++;
				break;
			}
		}
	}
	else if (IsColorCodeChar(GetChar(s, i)))
	{
		return i + 1;
	}
	
	return i;
}
	
function str GetColorCodeAt(str s, int i)
{
	return StrSlice(s, i, SkipColorCodeAt(s, i));
}
	
function bool HasColorCodes(str s)
{
	int len = StrLen(s);
	for (int i = 0; i < len; i++)
	{
		if (GetChar(s, i) == COLORCODE)
			i += 1;
		else
			continue;
			
		int c = GetChar(s, i);
		if (c == '[' || IsColorCodeChar(c))
			return true;
	}
	return false;
}

function str StripColorCodes(str s)
{
	str result = "";
	for (int i = 0; i < StrLen(s); i++)
	{
		i = SkipColorCodeAt(s, i);
		result = StrParam(s:result, c:GetChar(s, i));
	}

	return result;
}

#libdefine MAX_PLAYERS 64
#libdefine MAX_PLAYERS_ZDOOM 8
#libdefine TEAM_NONE 255

// Inventory functions.

function void GiveMaxInventory(str item)
{
	GiveInventory(item, INT_MAX);
}

function void GiveMaxActorInventory(int tid, str item)
{
	GiveActorInventory(tid, item, INT_MAX);
}

function void TakeMaxInventory(str item)
{
	TakeInventory(item, INT_MAX);
}

function void TakeMaxActorInventory(int tid, str item)
{
	TakeActorInventory(tid, item, INT_MAX);
}

function void SetInventory(str item, int amount)
{
	int diff = amount - CheckInventory(item);
	if (diff > 0)
		GiveInventory(item, diff);
	else if (diff < 0)
		TakeInventory(item, -diff);
}

function void SetActorInventory(int tid, str item, int amount)
{
	int diff = amount - CheckActorInventory(tid, item);
	if (diff > 0)
		GiveActorInventory(tid, item, diff);
	else if (diff < 0)
		TakeActorInventory(tid, item, -diff);
}

function void ToggleInventory(str item)
{
	if (CheckInventory(item) > 0)
		SetInventory(item, 0);
	else
		SetInventory(item, 1);
}

function void ToggleActorInventory(int tid, str item)
{
	if (CheckActorInventory(tid, item) > 0)
		SetActorInventory(tid, item, 0);
	else
		SetActorInventory(tid, item, 1);
}


// CVar functions.

function int a_GetCVarFixed(str name)
{
	str value = GetCVarString(name);
	if ((value) != 0)
		return atof(GetCVarString(name));
	return 0.0;
}

function int a_GetUserCVarFixed(int player, str name)
{
	str value = GetUserCVarString(player, name);
	if ((value) != 0)
		return atof(GetUserCVarString(player, name));
	return 0.0;
}


// Screen info functions.

function bool StatusBarVisible(void)
{
	return GetCVar("screenblocks") <= 10;
}


// HudMessage functions

function void ClearHudMessage(int id)
{
	HudMessage(s:""; HUDMSG_PLAIN, id, 0, 0.0, 0.0, 0.0, 0.0);
}

function void ClearHudMessageBold(int id)
{
	HudMessageBold(s:""; HUDMSG_PLAIN, id, 0, 0.0, 0.0, 0.0, 0.0);
}


// Actor information functions

function str ActivatorName(void)
{
	return StrParam(n:0);
}

script "ACSUtils_GetActorName" (int tid)
{
	SetActivator(tid);
	SetResultValue((StrParam(n:0)));
}

function str GetActorName(int tid)
{
	return ACS_NamedExecuteWithResult("ACSUtils_GetActorName", tid);
}

function bool IsAlive(void)
{
	if (IsPlayer())
		if (!PlayerInGame(PlayerNumber()))
			return false;
	return GetActorProperty(0, APROP_HEALTH) > 0;
}

function bool ActorIsAlive(int tid)
{
	if (tid == 0 && IsPlayer())
		if (!PlayerInGame(PlayerNumber()))
			return false;
	return GetActorProperty(tid, APROP_HEALTH) > 0;
}

function bool ActorExists(int tid)
{
	if (tid != 0)
		return ClassifyActor(tid) != ACTOR_NONE;
	return notflag(ClassifyActor(tid), ACTOR_WORLD);
}

// Actor math functions.

function int ActorDistance(int tid1, int tid2)
{
	return VectorLength3D(GetActorX(tid2) - GetActorX(tid1),
	                      GetActorY(tid2) - GetActorY(tid1),
	                      GetActorZ(tid2) - GetActorZ(tid1));
}

function int ActorDistance2D(int tid1, int tid2)
{
	return VectorLength(GetActorX(tid2) - GetActorX(tid1),
	                    GetActorY(tid2) - GetActorY(tid1));
}

function int GetActorVelocity(int tid)
{
	return VectorLength3D(GetActorVelX(tid), GetActorVelY(tid), GetActorVelZ(tid));
}

function int GetActorXYVelocity(int tid)
{
	return VectorLength(GetActorVelX(tid), GetActorVelY(tid));
}

function int GetActorVelocityXY(int tid)
{
	return VectorLength(GetActorVelX(tid), GetActorVelY(tid));
}

// Actor utility functions.

function bool HasRoomFor(str classname, int x, int y, int z)
{
	int tid = UniqueTid();
	if (!Spawn(classname, x, y, z, tid))
		return false;
	Thing_Remove(tid);
	return true;
}

function void LookAtPoint(int tid, int x, int y, int z)
{ 	
	x -= GetActorX(tid);
	y -= GetActorY(tid);
	z -= GetActorZ(tid) + GetActorViewHeight(tid);

	VectorToAngles(x, y, z);
	int angle = r1;
	int pitch = r2;

	SetActorAngle(tid, angle);
	SetActorPitch(tid, -pitch);
}

function void LookAt(int tid, int target)
{
	int x = GetActorX(target);
	int y = GetActorY(target);
	int z = GetActorZ(target) + GetActorViewHeight(target);
	LookAtPoint(tid, x, y, z);
}


// ChangeFlag

// Implementation from ACS-X.

function str ACSUtils_ChangeFlagName(str flag, bool value)
{
	return StrParam(s:"ACSUtils_CF_", s:flag, s:"_", d:(!!value));
}

function void ChangeFlag(str flag, bool value)
{
	GiveInventory(ACSUtils_ChangeFlagName(flag, value), 1);
}

function void ChangeActorFlag(int tid, str flag, bool value)
{
	GiveActorInventory(tid, ACSUtils_ChangeFlagName(flag, value), 1);
}


// Mapping functions.

// From ZDoom wiki.
function int SyncSpeed(int newdistance, int syncdistance, int syncspd)
{
	int t = fixeddiv((syncdistance<<16), (syncspd<<16));
	int r = fixeddiv((newdistance<<16), t);
	return (r)>>16;
}
//===========================
// INTEGER PACKING
//===========================

// Pack unsigned 8-bit values. ========================================
function int PackBytes(int a, int b, int c, int d)
{
	return (a<<24) | (b<<16) | (c<<8) | d;
}
function int UnpackByte1(int x) { return (x>>24) & 0x000000FF; }
function int UnpackByte2(int x) { return (x>>16) & 0x000000FF; }
function int UnpackByte3(int x) { return (x>>8)  & 0x000000FF; }
function int UnpackByte4(int x) { return (x>>0)  & 0x000000FF; }


// Pack signed 16-bit values. =========================================
function int PackShorts(int a, int b)
{
	return ((a + 0x8000)<<16) | ((b + 0x8000) & 0x0000FFFF);
}
function int UnpackShort1(int x) { return ((x>>16) & 0x0000FFFF) - 0x8000; }
function int UnpackShort2(int x) { return ((x    ) & 0x0000FFFF) - 0x8000; }
// By FusedQyou
function bool KeyBound (str key)
{
	if (!IsClient())
	{
		ACSUtils_ProgramError(StrParam(s:"KeyBound called serverside with key = \"", s:key, s:"\", returning false"));
		return false;
	}
	return !StrEquals(StrParam(k:key), StrParam(s:"??? (", s:key, s:")"));
}

// By Monsterovich.

function bool KeyUp(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if ((~buttons & key) == key) { return true; }
		return false;
}

function bool KeyUpAny(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if (~buttons & key) { return true; }
		return false;
}

function bool PlayerKeyUp(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if ((~buttons & key) == key) { return true; }
		return false;
}

function bool PlayerKeyUpAny(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if (~buttons & key) { return true; }
		return false;
}


function bool KeyDown(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if ((buttons & key) == key) { return true; }
		return false;
}

function bool KeyDownAny(int key)
{
	int buttons = GetPlayerInput(-1, INPUT_BUTTONS);

	if (buttons & key) { return true; }
		return false;
}

function bool PlayerKeyDown(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if ((buttons & key) == key) { return true; }
		return false;
}

function bool PlayerKeyDownAny(int player, int key)
{
	int buttons = GetPlayerInput(player, INPUT_BUTTONS);

	if (buttons & key) { return true; }
		return false;
}


function bool KeyPressed(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool KeyPressedAny(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if (newbuttons & key) { return true; }
		return false;
}

function bool PlayerKeyPressed(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool PlayerKeyPressedAny(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & buttons;

	if (newbuttons & key) { return true; }
		return false;
}


function bool KeyReleased(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool KeyReleasedAny(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if (newbuttons & key) { return true; }
		return false;
}

function bool PlayerKeyReleased(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool PlayerKeyReleasedAny(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons) & oldbuttons;

	if (newbuttons & key) { return true; }
		return false;
}


function bool KeyToggled(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool KeyToggledAny(int key)
{
	int buttons     = GetPlayerInput(-1, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(-1, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if (newbuttons & key) { return true; }
		return false;
}

function bool PlayerKeyToggled(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if ((newbuttons & key) == key) { return true; }
		return false;
}

function bool PlayerKeyToggledAny(int player, int key)
{
	int buttons     = GetPlayerInput(player, INPUT_BUTTONS);
	int oldbuttons  = GetPlayerInput(player, INPUT_OLDBUTTONS);
	int newbuttons  = (buttons ^ oldbuttons);

	if (newbuttons & key) { return true; }
		return false;
}
// Angles

function int deg2ang(int degrees)
{
	return FixedDiv(degrees, 360.0);
}

function int rad2ang(int radians)
{
	return FixedDiv(radians, TAU);
}

function int ang2deg(int angle)
{
	return FixedMul(angle, 360.0);
}

function int ang2rad(int angle)
{
	return FixedMul(angle, TAU);
}

function int deg2rad(int degrees)
{
	return FixedDiv(degrees, 57.29577951308232);
}

function int rad2deg(int radians)
{
	return FixedMul(radians, 57.29577951308232);
}

function int ang2byte(int angle)
{
    return (angle)>>8;
}

function int byte2ang(int angle)
{
    return (angle<<8);
}

// Gravity

function int GetGravityG(void)
{
	int sv_gravity = GetCVar("sv_gravity");
	if (sv_gravity > SHORT_MAX || sv_gravity < SHORT_MIN)
		return IntDiv(sv_gravity, 800);
	return FixedDiv(a_GetCVarFixed("sv_gravity"), 800.0);
}

function void SetGravityG(int gravity)
{
	SetGravity(FixedMul(gravity, 800.0));
}

function int grav2accel(int grav)
{
	return FixedDiv(grav, 800.0);
}

function int accel2grav(int accel)
{
	return FixedMul(accel, 800.0);
}

function int height2jumpz(int height, int gravity)
{
	return FixedSqrt((2 * (FixedMul(height, gravity))));
}

function int jumpz2height(int jumpz, int gravity)
{
	return ((FixedDiv(FixedMul(jumpz, jumpz), gravity)) / 2);
}

#libdefine PARSENUMBER_SUCCESS 0
#libdefine PARSENUMBER_OVERFLOW 1
#libdefine PARSENUMBER_BADFORMAT 2

function int ACSUtils_CheckRadix(int radix, str functionName)
{
	if (radix <= 0)
	{
		ACSUtils_ProgramError(StrParam(s:functionName, s:": invalid radix ", d:radix, s:". Assuming base 10."));
		return 10;
	}
	else if (radix > 36)
	{
		ACSUtils_ProgramError(StrParam(s:functionName, s:" only supports bases up to 36 (10 digits + 26 letters), but was requested to parse base ", d:radix, s:". Assuming base 10."));
		return 10;
	}
	return radix;
}

function void ACSUtils_ParseSign(str s, int i)
{
	if (GetChar(s, i) == '+')
	{
		r1 = 1;
		r2 = i + 1;
		return;
	}
	else if (GetChar(s, i) == '-')
	{
		r1 = -1;
		r2 = i + 1;
		return;
	}
	
	r1 = 1;
	r2 = i;
	return;
}
	
function void ACSUtils_ParseBasePrefix(str s, int i)
{
	if (StrIEqualsAt(s, i, "0x"))
	{
		r1 = 16;
		r2 = i + 2;
		return;
	}
	else if (StrIEqualsAt(s, i, "0o"))
	{
		r1 = 8;
		r2 = i + 2;
		return;
	}
	else if (StrIEqualsAt(s, i, "0b"))
	{
		r1 = 2;
		r2 = i + 2;
		return;
	}
	
	r1 = 0;
	r2 = i;
	return;
}

function int ACSUtils_ParseDigit(int c, int radix)
{
	int digit;
	if (c >= '0' && c <= '9')
		digit = c - '0';
	else if (c >= 'a' && c <= 'z')
		digit = c - 'a' + 10;
	else if (c >= 'A' && c <= 'Z')
		digit = c - 'A' + 10;
	else
		return -1;
		
	if (digit < radix)
		return digit;
	return -1;
}

function void ParseInt(str s, int radix)
{
	int i = 0;
	int sign = 1;
	radix = ACSUtils_CheckRadix(radix, "ParseInt");
	
	ACSUtils_ParseSign(s, i);
	sign = r1;
	i = r2;

	ACSUtils_ParseBasePrefix(s, i);
	radix = condFalse(r1, radix);
	i = r2;
	
	int len = StrLen(s);
	if (i == len)
	{
		r1 = PARSENUMBER_BADFORMAT;
		r2 = 0;
	}	
	
	int maxresult = cond(sign > 0, INT_MAX, INT_MIN);
	int limit = abs(maxresult / radix);
	int result = 0;
	bool overflowed = false;
	for (; i < len; i++)
	{
		int c = GetChar(s, i);
		int digit = ACSUtils_ParseDigit(c, radix);
		if (digit < 0)
		{
			r1 = PARSENUMBER_BADFORMAT;
			r2 = 0;
			return;
		}
		
		if (limit >= abs(result) && result != INT_MIN)
			result = result * radix + sign * digit;
		else
			overflowed = true;			
	}
	
	if (overflowed)
	{
		r1 = PARSENUMBER_OVERFLOW;
		r2 = maxresult;
		return;
	}
	else
	{
		r1 = PARSENUMBER_SUCCESS;
		r2 = result;
		return;
	}
}
	
function void ParseFixed(str s, int radix)
{
	int i = 0;
	int sign = 1;
	radix = ACSUtils_CheckRadix(radix, "ParseFixed");
	
	ACSUtils_ParseSign(s, i);
	sign = r1;
	i = r2;

	ACSUtils_ParseBasePrefix(s, i);
	radix = condFalse(r1, radix);
	i = r2;
	
	int len = StrLen(s);
	if (i == len)
	{
		r1 = PARSENUMBER_BADFORMAT;
		r2 = 0;
	}
	
	int maxresult = cond(sign > 0, INT_MAX, INT_MIN);
	int limit = abs(maxresult / radix);
	int result = 0;
	bool overflowed = false;
	bool hasfraction = false;
	int digit;
	for (; i < len; i++)
	{
		int c = GetChar(s, i);
		if (c == '.')
		{
			hasfraction = true;
			break;
		}
		
		digit = ACSUtils_ParseDigit(c, radix);
		if (digit < 0)
		{
			r1 = PARSENUMBER_BADFORMAT;
			r2 = 0;
			return;
		}
		
		if (limit >= abs(result) && result != INT_MIN)
			result = result * radix + sign * (digit<<16);
		else
			overflowed = true;			
	}
	
	if (hasfraction)
	{
		i++;
		
		int divisor = radix;
		for (; i < len; i++)
		{
			digit = ACSUtils_ParseDigit(GetChar(s, i), radix);
			if (digit < 0)
			{
				r1 = PARSENUMBER_BADFORMAT;
				r2 = 0;
				return;
			}
			
			if (divisor <= (radix<<16))
			{
				result = result + sign * (digit<<16) / divisor;
				if (sign < 0 && result > 0)
				{
					overflowed = true;
					break;
				}
				divisor *= radix;
			}
		}
	}			
	
	if (overflowed)
	{
		r1 = PARSENUMBER_OVERFLOW;
		r2 = maxresult;
		return;
	}
	else
	{
		r1 = PARSENUMBER_SUCCESS;
		r2 = result;
		return;
	}
}
	

function int atoi(str s)
{
	ParseInt(s, 10);
	return r2;
}

function int atof(str s)
{
	ParseFixed(s, 10);
	return r2;
}

function bool StrIsInt(str s)
{
	ParseInt(s, 10);
	return r1 != PARSENUMBER_BADFORMAT;
}

function bool StrIsFixed(str s)
{
	ParseFixed(s, 10);
	return r1 != PARSENUMBER_BADFORMAT;
}
// Actor property shorthands with network optimization.
// Idea from AOW.


/*
int Accuracy
int Alpha
bool Ambush
int AttackZOffset
bool ChaseGoal
int Damage
int DamageFactor
int DamageMultiplier
bool Dormant
bool Dropped
int Friction
bool Friendly
bool Frightened
int Gravity
int Health
int Height
bool Invulnerable
int JumpZ
int Mass
int MasterTID
int MaxDropOffHeight
int MaxStepHeight
int MeleeRange
bool NoTrigger
bool NoTarget
int Radius
int ReactionTime
int RenderStyle
int ScaleX
int ScaleY
int Score
int SpawnHealth
int Speed
int Stamina
int StencilColor
int TargetTID
int TracerTID
int ViewHeight
int Waterlevel
str DamageType
str Nametag
str Species
str ActiveSound
str AttackSound
str DeathSound
str PainSound
str SeeSound
*/

function int GetActorAccuracy(int tid) { return GetActorProperty(tid, APROP_Accuracy); }
function void SetActorAccuracy(int tid, int Accuracy)
{
	if (GetActorProperty(tid, APROP_Accuracy) != Accuracy)
		SetActorProperty(tid, APROP_Accuracy, Accuracy);
}

function int GetActorAlpha(int tid) { return GetActorProperty(tid, APROP_Alpha); }
function void SetActorAlpha(int tid, int Alpha)
{
	if (GetActorProperty(tid, APROP_Alpha) != Alpha)
		SetActorProperty(tid, APROP_Alpha, Alpha);
}

function bool GetActorAmbush(int tid) { return GetActorProperty(tid, APROP_Ambush); }
function void SetActorAmbush(int tid, bool Ambush)
{
	if (GetActorProperty(tid, APROP_Ambush) != Ambush)
		SetActorProperty(tid, APROP_Ambush, Ambush);
}

function int GetActorAttackZOffset(int tid) { return GetActorProperty(tid, APROP_AttackZOffset); }
function void SetActorAttackZOffset(int tid, int AttackZOffset)
{
	if (GetActorProperty(tid, APROP_AttackZOffset) != AttackZOffset)
		SetActorProperty(tid, APROP_AttackZOffset, AttackZOffset);
}

function bool GetActorChaseGoal(int tid) { return GetActorProperty(tid, APROP_ChaseGoal); }
function void SetActorChaseGoal(int tid, bool ChaseGoal)
{
	if (GetActorProperty(tid, APROP_ChaseGoal) != ChaseGoal)
		SetActorProperty(tid, APROP_ChaseGoal, ChaseGoal);
}

function int GetActorDamage(int tid) { return GetActorProperty(tid, APROP_Damage); }
function void SetActorDamage(int tid, int Damage)
{
	if (GetActorProperty(tid, APROP_Damage) != Damage)
		SetActorProperty(tid, APROP_Damage, Damage);
}

function int GetActorDamageFactor(int tid) { return GetActorProperty(tid, APROP_DamageFactor); }
function void SetActorDamageFactor(int tid, int DamageFactor)
{
	if (GetActorProperty(tid, APROP_DamageFactor) != DamageFactor)
		SetActorProperty(tid, APROP_DamageFactor, DamageFactor);
}

function int GetActorDamageMultiplier(int tid) { return GetActorProperty(tid, APROP_DamageMultiplier); }
function void SetActorDamageMultiplier(int tid, int DamageMultiplier)
{
	if (GetActorProperty(tid, APROP_DamageMultiplier) != DamageMultiplier)
		SetActorProperty(tid, APROP_DamageMultiplier, DamageMultiplier);
}

function bool GetActorDormant(int tid) { return GetActorProperty(tid, APROP_Dormant); }
function void SetActorDormant(int tid, bool Dormant)
{
	if (GetActorProperty(tid, APROP_Dormant) != Dormant)
		SetActorProperty(tid, APROP_Dormant, Dormant);
}

function bool GetActorDropped(int tid) { return GetActorProperty(tid, APROP_Dropped); }
function void SetActorDropped(int tid, bool Dropped)
{
	if (GetActorProperty(tid, APROP_Dropped) != Dropped)
		SetActorProperty(tid, APROP_Dropped, Dropped);
}

function int GetActorFriction(int tid) { return GetActorProperty(tid, APROP_Friction); }
function void SetActorFriction(int tid, int Friction)
{
	if (GetActorProperty(tid, APROP_Friction) != Friction)
		SetActorProperty(tid, APROP_Friction, Friction);
}

function bool GetActorFriendly(int tid) { return GetActorProperty(tid, APROP_Friendly); }
function void SetActorFriendly(int tid, bool Friendly)
{
	if (GetActorProperty(tid, APROP_Friendly) != Friendly)
		SetActorProperty(tid, APROP_Friendly, Friendly);
}

function bool GetActorFrightened(int tid) { return GetActorProperty(tid, APROP_Frightened); }
function void SetActorFrightened(int tid, bool Frightened)
{
	if (GetActorProperty(tid, APROP_Frightened) != Frightened)
		SetActorProperty(tid, APROP_Frightened, Frightened);
}

function int GetActorGravity(int tid) { return GetActorProperty(tid, APROP_Gravity); }
function void SetActorGravity(int tid, int Gravity)
{
	if (GetActorProperty(tid, APROP_Gravity) != Gravity)
		SetActorProperty(tid, APROP_Gravity, Gravity);
}

function int GetActorHealth(int tid) { return GetActorProperty(tid, APROP_Health); }
function void SetActorHealth(int tid, int Health)
{
	if (GetActorProperty(tid, APROP_Health) != Health)
		SetActorProperty(tid, APROP_Health, Health);
}

function int GetActorHeight(int tid) { return GetActorProperty(tid, APROP_Height); }
function void SetActorHeight(int tid, int Height)
{
	if (GetActorProperty(tid, APROP_Height) != Height)
		SetActorProperty(tid, APROP_Height, Height);
}

function bool GetActorInvulnerable(int tid) { return GetActorProperty(tid, APROP_Invulnerable); }
function void SetActorInvulnerable(int tid, bool Invulnerable)
{
	if (GetActorProperty(tid, APROP_Invulnerable) != Invulnerable)
		SetActorProperty(tid, APROP_Invulnerable, Invulnerable);
}

function int GetActorJumpZ(int tid) { return GetActorProperty(tid, APROP_JumpZ); }
function void SetActorJumpZ(int tid, int JumpZ)
{
	if (GetActorProperty(tid, APROP_JumpZ) != JumpZ)
		SetActorProperty(tid, APROP_JumpZ, JumpZ);
}

function int GetActorMass(int tid) { return GetActorProperty(tid, APROP_Mass); }
function void SetActorMass(int tid, int Mass)
{
	if (GetActorProperty(tid, APROP_Mass) != Mass)
		SetActorProperty(tid, APROP_Mass, Mass);
}

function int GetActorMasterTID(int tid) { return GetActorProperty(tid, APROP_MasterTID); }
function void SetActorMasterTID(int tid, int MasterTID)
{
	if (GetActorProperty(tid, APROP_MasterTID) != MasterTID)
		SetActorProperty(tid, APROP_MasterTID, MasterTID);
}

function int GetActorMaxDropOffHeight(int tid) { return GetActorProperty(tid, APROP_MaxDropOffHeight); }
function void SetActorMaxDropOffHeight(int tid, int MaxDropOffHeight)
{
	if (GetActorProperty(tid, APROP_MaxDropOffHeight) != MaxDropOffHeight)
		SetActorProperty(tid, APROP_MaxDropOffHeight, MaxDropOffHeight);
}

function int GetActorMaxStepHeight(int tid) { return GetActorProperty(tid, APROP_MaxStepHeight); }
function void SetActorMaxStepHeight(int tid, int MaxStepHeight)
{
	if (GetActorProperty(tid, APROP_MaxStepHeight) != MaxStepHeight)
		SetActorProperty(tid, APROP_MaxStepHeight, MaxStepHeight);
}

function int GetActorMeleeRange(int tid) { return GetActorProperty(tid, APROP_MeleeRange); }
function void SetActorMeleeRange(int tid, int MeleeRange)
{
	if (GetActorProperty(tid, APROP_MeleeRange) != MeleeRange)
		SetActorProperty(tid, APROP_MeleeRange, MeleeRange);
}

function bool GetActorNoTrigger(int tid) { return GetActorProperty(tid, APROP_NoTrigger); }
function void SetActorNoTrigger(int tid, bool NoTrigger)
{
	if (GetActorProperty(tid, APROP_NoTrigger) != NoTrigger)
		SetActorProperty(tid, APROP_NoTrigger, NoTrigger);
}

function bool GetActorNoTarget(int tid) { return GetActorProperty(tid, APROP_NoTarget); }
function void SetActorNoTarget(int tid, bool NoTarget)
{
	if (GetActorProperty(tid, APROP_NoTarget) != NoTarget)
		SetActorProperty(tid, APROP_NoTarget, NoTarget);
}

function int GetActorRadius(int tid) { return GetActorProperty(tid, APROP_Radius); }
function void SetActorRadius(int tid, int Radius)
{
	if (GetActorProperty(tid, APROP_Radius) != Radius)
		SetActorProperty(tid, APROP_Radius, Radius);
}

function int GetActorReactionTime(int tid) { return GetActorProperty(tid, APROP_ReactionTime); }
function void SetActorReactionTime(int tid, int ReactionTime)
{
	if (GetActorProperty(tid, APROP_ReactionTime) != ReactionTime)
		SetActorProperty(tid, APROP_ReactionTime, ReactionTime);
}

function int GetActorRenderStyle(int tid) { return GetActorProperty(tid, APROP_RenderStyle); }
function void SetActorRenderStyle(int tid, int RenderStyle)
{
	if (GetActorProperty(tid, APROP_RenderStyle) != RenderStyle)
		SetActorProperty(tid, APROP_RenderStyle, RenderStyle);
}

function int GetActorScaleX(int tid) { return GetActorProperty(tid, APROP_ScaleX); }
function void SetActorScaleX(int tid, int ScaleX)
{
	if (GetActorProperty(tid, APROP_ScaleX) != ScaleX)
		SetActorProperty(tid, APROP_ScaleX, ScaleX);
}

function int GetActorScaleY(int tid) { return GetActorProperty(tid, APROP_ScaleY); }
function void SetActorScaleY(int tid, int ScaleY)
{
	if (GetActorProperty(tid, APROP_ScaleY) != ScaleY)
		SetActorProperty(tid, APROP_ScaleY, ScaleY);
}

function int GetActorScore(int tid) { return GetActorProperty(tid, APROP_Score); }
function void SetActorScore(int tid, int Score)
{
	if (GetActorProperty(tid, APROP_Score) != Score)
		SetActorProperty(tid, APROP_Score, Score);
}

function int GetActorSpawnHealth(int tid) { return GetActorProperty(tid, APROP_SpawnHealth); }
function void SetActorSpawnHealth(int tid, int SpawnHealth)
{
	if (GetActorProperty(tid, APROP_SpawnHealth) != SpawnHealth)
		SetActorProperty(tid, APROP_SpawnHealth, SpawnHealth);
}

function int GetActorSpeed(int tid) { return GetActorProperty(tid, APROP_Speed); }
function void SetActorSpeed(int tid, int Speed)
{
	if (GetActorProperty(tid, APROP_Speed) != Speed)
		SetActorProperty(tid, APROP_Speed, Speed);
}

function int GetActorStamina(int tid) { return GetActorProperty(tid, APROP_Stamina); }
function void SetActorStamina(int tid, int Stamina)
{
	if (GetActorProperty(tid, APROP_Stamina) != Stamina)
		SetActorProperty(tid, APROP_Stamina, Stamina);
}

function int GetActorStencilColor(int tid) { return GetActorProperty(tid, APROP_StencilColor); }
function void SetActorStencilColor(int tid, int StencilColor)
{
	if (GetActorProperty(tid, APROP_StencilColor) != StencilColor)
		SetActorProperty(tid, APROP_StencilColor, StencilColor);
}

function int GetActorTargetTID(int tid) { return GetActorProperty(tid, APROP_TargetTID); }
function void SetActorTargetTID(int tid, int TargetTID)
{
	if (GetActorProperty(tid, APROP_TargetTID) != TargetTID)
		SetActorProperty(tid, APROP_TargetTID, TargetTID);
}

function int GetActorTracerTID(int tid) { return GetActorProperty(tid, APROP_TracerTID); }
function void SetActorTracerTID(int tid, int TracerTID)
{
	if (GetActorProperty(tid, APROP_TracerTID) != TracerTID)
		SetActorProperty(tid, APROP_TracerTID, TracerTID);
}

// GetActorViewHeight is native
function void SetActorViewHeight(int tid, int ViewHeight)
{
	if (GetActorProperty(tid, APROP_ViewHeight) != ViewHeight)
		SetActorProperty(tid, APROP_ViewHeight, ViewHeight);
}

function int GetActorWaterlevel(int tid) { return GetActorProperty(tid, APROP_Waterlevel); }
function void SetActorWaterlevel(int tid, int Waterlevel)
{
	if (GetActorProperty(tid, APROP_Waterlevel) != Waterlevel)
		SetActorProperty(tid, APROP_Waterlevel, Waterlevel);
}

// String properties.
function str GetActorDamageType(int tid) { return GetActorProperty(tid, APROP_DamageType); }
function void SetActorDamageType(int tid, str DamageType)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_DamageType), DamageType))
		SetActorProperty(tid, APROP_DamageType, DamageType);
}

function str GetActorNametag(int tid) { return GetActorProperty(tid, APROP_Nametag); }
function void SetActorNametag(int tid, str Nametag)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_Nametag), Nametag))
		SetActorProperty(tid, APROP_Nametag, Nametag);
}

function str GetActorSpecies(int tid) { return GetActorProperty(tid, APROP_Species); }
function void SetActorSpecies(int tid, str Species)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_Species), Species))
		SetActorProperty(tid, APROP_Species, Species);
}

function str GetActorActiveSound(int tid) { return GetActorProperty(tid, APROP_ActiveSound); }
function void SetActorActiveSound(int tid, str ActiveSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_ActiveSound), ActiveSound))
		SetActorProperty(tid, APROP_ActiveSound, ActiveSound);
}

function str GetActorAttackSound(int tid) { return GetActorProperty(tid, APROP_AttackSound); }
function void SetActorAttackSound(int tid, str AttackSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_AttackSound), AttackSound))
		SetActorProperty(tid, APROP_AttackSound, AttackSound);
}

function str GetActorDeathSound(int tid) { return GetActorProperty(tid, APROP_DeathSound); }
function void SetActorDeathSound(int tid, str DeathSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_DeathSound), DeathSound))
		SetActorProperty(tid, APROP_DeathSound, DeathSound);
}

function str GetActorPainSound(int tid) { return GetActorProperty(tid, APROP_PainSound); }
function void SetActorPainSound(int tid, str PainSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_PainSound), PainSound))
		SetActorProperty(tid, APROP_PainSound, PainSound);
}

function str GetActorSeeSound(int tid) { return GetActorProperty(tid, APROP_SeeSound); }
function void SetActorSeeSound(int tid, str SeeSound)
{
	if (!StrIEquals(GetActorProperty(tid, APROP_SeeSound), SeeSound))
		SetActorProperty(tid, APROP_SeeSound, SeeSound);
}


function bool IsPlayer(void)
{
	return PlayerNumber() >= 0;
}

script "ACSUtils_ActorPlayerNumber" (int tid)
{
	SetActivator(tid);
	SetResultValue(PlayerNumber());
}

function int ActorPlayerNumber(int tid)
{
	return ACS_NamedExecuteWithResult("ACSUtils_ActorPlayerNumber", tid);
}

function bool ActorIsPlayer(int tid)
{
	return ClassifyActor(tid) & ACTOR_PLAYER;
}

function str PlayerName(int player)
{
	return StrParam(n:player + 1);
}

function int GetPlayerTeam(int player)
{
	return GetPlayerInfo(player, PLAYERINFO_TEAM);
}

function int TeamPlayerCount(int team)
{
	return GetTeamProperty(team, TPROP_NumPlayers);
}


// ConsolePlayer stuff
function bool ConsolePlayerInGame(void)
{
	return PlayerInGame(ConsolePlayerNumber());
}

function str ConsolePlayerName(void)
{
	return PlayerName(ConsolePlayerNumber());
}

function int ConsolePlayerTeam(void)
{
	return GetPlayerTeam(ConsolePlayerNumber());
}




// PlayerIsBot is native

function bool PlayerIsConnected(int player)
{
	return PlayerInGame(player) || PlayerIsSpectator(player);
}

function bool PlayerIsDeadSpectator(int player)
{
	return PlayerIsSpectator(player) == 2;
}

// PlayerInGame is native

// PlayerIsSpectator is native


function int BotCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsBot(i))
			count++;
	return count;
}

function int ClientCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsConnected(i))
			count++;
	return count;
}

function int DeadSpectatorCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsDeadSpectator(i))
			count++;
	return count;
}

// PlayerCount is native

function int SpectatorCount(void)
{
	int count = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsSpectator(i))
			count++;
	return count;
}


int ACSUtils_Players[MAX_PLAYERS];

function int PickRandomBot(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsBot(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

function int PickRandomClient(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsConnected(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

function int PickRandomDeadSpectator(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsDeadSpectator(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

function int PickRandomPlayer(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerInGame(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

function int PickRandomSpectator(void)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerIsSpectator(i))
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}

function int PickRandomTeamPlayer(int team)
{
	int numPlayers = 0;
	for (int i = 0; i < MAX_PLAYERS; i++)
		if (PlayerInGame(i) && GetPlayerTeam(i) == team)
			ACSUtils_Players[numPlayers++] = i;
	
	if (numPlayers == 0)
		return -1;
	
	return ACSUtils_Players[Random(0, numPlayers - 1)];
}


















	

function int CursorX(void)
{
	return ACSUtils_Ints[35];
}

function int CursorY(void)
{
	return ACSUtils_Ints[0];
}

function int CursorDeltaX(void)
{
	if (ACSUtils_Ints[8])
		return CursorMotionX();
	return ACSUtils_Ints[35] - ACSUtils_Ints[16];
}
function int CursorDeltaY(void)
{
	if (ACSUtils_Ints[43])
		return CursorMotionY();
	return ACSUtils_Ints[0] - ACSUtils_Ints[47];
}

function int CursorMotionX(void)
{
	return ACSUtils_Ints[29];
}

function int CursorMotionY(void)
{
	return ACSUtils_Ints[38];
}

function void SetCursorSpeed(int speed)
{
	ACSUtils_Ints[31] = speed;
	ACSUtils_Ints[7] = speed;
}

function void SetCursorSpeedX(int speed)
{
	ACSUtils_Ints[31] = speed;
}

function void SetCursorSpeedY(int speed)
{
	ACSUtils_Ints[7] = speed;
}

function void SetCursorPosition(int x, int y)
{
	ACSUtils_Ints[35] = x;
	ACSUtils_Ints[0] = y;
}

function void CenterCursor(void)
{
	SetCursorPosition(ACSUtils_Ints[53] / 2, ACSUtils_Ints[2] / 2);
}

function void EnableCursorWrap(bool enable)
{
	ACSUtils_Ints[8] = enable;
	ACSUtils_Ints[43] = enable;
}

function void EnableCursorWrapX(bool enable)
{
	ACSUtils_Ints[8] = enable;
}

function void EnableCursorWrapY(bool enable)
{
	ACSUtils_Ints[43] = enable;
}

function void ACSUtils_ClampCursor(void)
{
	int width = ACSUtils_Ints[53];
	int height = ACSUtils_Ints[2];
	
	int borderX = HudBorderXFor(width);
	int borderY = HudBorderYFor(height);
	
	ACSUtils_Ints[35] += borderX;
	ACSUtils_Ints[0] += borderY;
	
	width +=  ((borderX) * 2);
	height += ((borderY) * 2);

	if (ACSUtils_Ints[8])
		ACSUtils_Ints[35] = mod(ACSUtils_Ints[35], width);
	else
		ACSUtils_Ints[35] = clamp(ACSUtils_Ints[35], 0, width);
	
	if (ACSUtils_Ints[43])
		ACSUtils_Ints[0] = mod(ACSUtils_Ints[0], height);
	else
		ACSUtils_Ints[0] = clamp(ACSUtils_Ints[0], 0, height);
		
	ACSUtils_Ints[35] -= borderX;
	ACSUtils_Ints[0] -= borderY;
}

function void SetCursorArea(int width, int height)
{
	if (width <= 0.0)
		ACSUtils_ProgramError(StrParam(s:"Cursor area width set to ", f:width));
	if (height <= 0.0)
		ACSUtils_ProgramError(StrParam(s:"Cursor area height set to ", f:height));
	
	ACSUtils_Ints[35] = FixedMul(ACSUtils_Ints[35], FixedDiv(width, ACSUtils_Ints[53]));
	ACSUtils_Ints[0] = FixedMul(ACSUtils_Ints[0], FixedDiv(height, ACSUtils_Ints[2]));
	ACSUtils_Ints[16] = FixedMul(ACSUtils_Ints[16], FixedDiv(width, ACSUtils_Ints[53]));
	ACSUtils_Ints[47] = FixedMul(ACSUtils_Ints[47], FixedDiv(height, ACSUtils_Ints[2]));
	ACSUtils_Ints[29] = FixedMul(ACSUtils_Ints[29], FixedDiv(width, ACSUtils_Ints[53]));
	ACSUtils_Ints[38] = FixedMul(ACSUtils_Ints[38], FixedDiv(height, ACSUtils_Ints[2]));

	ACSUtils_Ints[53] = width;
	ACSUtils_Ints[2] = height;
}

function void UpdateCursor(void)
{
	ACSUtils_Ints[16] = ACSUtils_Ints[35];
	ACSUtils_Ints[47] = ACSUtils_Ints[0];

	int sensitivity = a_GetCVarFixed("mouse_sensitivity");
	int speedX = FixedDiv(ACSUtils_Ints[31], FixedMul(a_GetCVarFixed("m_yaw"), sensitivity));
	int speedY = FixedDiv(ACSUtils_Ints[7], FixedMul(a_GetCVarFixed("m_pitch"), sensitivity));
	
	speedX = ((FixedMul(((speedX) * 2), ACSUtils_Ints[53])) / 64000);
	speedY = ((FixedMul(((speedY) * 2), ACSUtils_Ints[2])) / 32000);

	int dx = (-GetPlayerInput(ConsolePlayerNumber(), INPUT_YAW)   * (speedX));
    int dy = (-GetPlayerInput(ConsolePlayerNumber(), INPUT_PITCH) * (speedY));

	if (GetCVar("invertmouse"))
        dy = -dy;
		
	ACSUtils_Ints[29] = dx;
	ACSUtils_Ints[38] = dy;
	ACSUtils_Ints[35] += dx;
	ACSUtils_Ints[0] += dy;
	ACSUtils_ClampCursor();
}

#libdefine PORT_ZDOOM 1
#libdefine PORT_GZDOOM 2
#libdefine PORT_ZANDRONUM 3



// Port identification methods copied from ACS-X
function int IdentifySourcePort(void)
{
	if (ACSUtils_Ints[4] != -1)
		return ACSUtils_Ints[4];

	if (GetPlayerAccountName(0) != 0)
	{
		// GetPlayerAccountName returns a string (possibly empty) in Zandronum
		// but 0 in GZDoom.
		ACSUtils_Ints[4] = PORT_ZANDRONUM;
		return ACSUtils_Ints[4];
	}
	
	int tid = UniqueTid();
	if (SpawnForced("DynamicLight", 0, 0, 0, tid))
	{
		// DynamicLight is a built-in actor in GZDoom.
		Thing_Remove(tid);
		ACSUtils_Ints[4] = PORT_GZDOOM;
		return ACSUtils_Ints[4];
	}
	
	ACSUtils_Ints[4] = PORT_ZDOOM;
	return ACSUtils_Ints[4];
}

function str GetPortName(void)
{
	int port = IdentifySourcePort();
	switch (port)
	{
	case PORT_ZDOOM:
		return "ZDoom";
	case PORT_GZDOOM:
		return "GZDoom";
	case PORT_ZANDRONUM:
		return "Zandronum";
	}

	return StrParam(s:"IdentifySourcePort() returned ", d:port);
}

function bool IsZandronum(void)
{
	return IdentifySourcePort() == PORT_ZANDRONUM;
}

function bool IsGZDoom(void)
{
	int port = IdentifySourcePort();
	return port == PORT_GZDOOM || port == PORT_ZANDRONUM;
}

function bool IsServer(void)
{
	if (ConsolePlayerNumber() < 0)
		return true;
		
	// Needs to be done like this to avoid crashing the script in ZDoom.
	if (IsZandronum())
		return !IsNetworkGame();
	
	return true;
}

function bool IsClient(void)
{
	return ConsolePlayerNumber() >= 0;
}

function bool IsServerOnly(void)
{
	return IsServer() && !IsClient();
}

function bool IsClientOnly(void)
{
	return IsClient() && !IsServer();
}

function bool IsOpenGL(void)
{
	if (!IsClient())
	{
		ACSUtils_ProgramError("IsOpenGL() used serverside. Assuming OpenGL renderer.");
		return true; // OpenGL generally has less limitations.
	}
	
	// Correctly identifies ZDoom with a config file from GZDoom with vid_renderer = 1.
	if (IsGZDoom())
		return GetCVar("vid_renderer") == 1 && GetCVar("gl_nogl") == 0;
	
	return false;
}

// Most of this file is written by carlcyber and bagheadspidey.
// See http://forum.zdoom.org/viewtopic.php?f=3&t=35383
// Interface 

// BCC type
#libdefine ASPECT_4_3 ((4.0) / 3)
#libdefine ASPECT_5_4 1.25
#libdefine ASPECT_16_9 ((16.0) / 9)
#libdefine ASPECT_16_10 1.6
#libdefine ASPECT_17_10 1.7

function int GetAspectRatio(void)
{
	if (!IsClient())
	{
		ACSUtils_ProgramError("GetAspectRatio() called serverside. Assuming 4:3.");
		return ASPECT_4_3;
	}

	int width = GetCVar("vid_defwidth");
	int height = GetCVar("vid_defheight");
	int nowidescreen = GetCVar("vid_nowidescreen");
	int tft = GetCVar("vid_tft");
	int aspect = GetCVar("vid_aspect");
	switch(aspect)
	{
		case 1:	return ASPECT_16_9;
		case 2:	return ASPECT_16_10;
		case 3:	return ASPECT_4_3;
		case 4:	return ASPECT_5_4;
		case 5: return ASPECT_17_10;
	}
	if(nowidescreen)
	{
		if(!tft)
			return ASPECT_4_3;
		if(height * ASPECT_5_4 == width<<16)
			return ASPECT_5_4;
		else
			return ASPECT_4_3;
	}
	if(abs((abs(height * ASPECT_16_9)>>16) - width) < 10)
	{
		return ASPECT_16_9;
	}
	if(abs((abs(height * ASPECT_17_10)>>16) - width) < 10)
	{
		return ASPECT_17_10;
	}
	if(abs((abs(height * ASPECT_16_10)>>16) - width) < 60)
	{
		if((width == 320 && height == 200) || (width == 640 && height == 400))
			return ASPECT_4_3;
		return ASPECT_16_10;
	}
	if((height * ASPECT_5_4)>>16 == width && tft)
	{
		return ASPECT_5_4;
	}
	return ASPECT_4_3;
}

/*
 * Gets the borders of the specified HUD size.
 * [NOTE]:
 *     1. The HUD borders are written in HudLeft, HudRight, HudTop, and HudBottom variables.
 *     2. Status bar and small screen blocks (screenblocks < 11) are not supported.
 * [Credit]
 *    Original HUD edge positioning functions by bagheadspidey
 */

function int HudBorderXFor(int width)
{
	int ar = GetAspectRatio();
	switch (ar)
	{
		case ASPECT_4_3: return 0.0;
		case ASPECT_16_9: return ((width) / 6);
		case ASPECT_16_10: return ((width) / 10);
		case ASPECT_17_10: return ((width) / 80);
	}
	return 0.0;
}

function int HudBorderYFor(int height)
{
	if (GetAspectRatio() == ASPECT_5_4)
		return ((height) / 30);
	return 0.0;
}

function int HudLeftFor(int width)
{
	return -HudBorderXFor(width);
}
function int HudX1For(int width)
{
	return -HudBorderXFor(width);
}

function int HudRightFor(int width)
{
	return width + HudBorderXFor(width);
}
function int HudX2For(int width)
{
	return width + HudBorderXFor(width);
}


function int HudTopFor(int height)
{
	return -HudBorderYFor(height);
}
function int HudY1For(int height)
{
	return -HudBorderYFor(height);
}

function int HudBottomFor(int height)
{
	return height + HudBorderYFor(height);
}
function int HudY2For(int height)
{
	return height + HudBorderYFor(height);
}

// Contributed to ACSUtils by Konda

// Sorts an array, given the named scripts for comparing and swapping array elements
function void SortArray(int begin_index, int end_index, str less_than, str cb_swap)
{
    ACSUtils_heap_sort(begin_index, end_index - 1, less_than, cb_swap);
    //_selection_sort(begin_index, end_index - 1, less_than, cb_swap);
}

/*
function void _selection_sort(int begin, int end, str lt, str cb_swap)
{
    for(int i = begin; i <= end-1; i++)
    for(int j = i+1; j <= end; j++)
        if(ACS_NamedExecuteWithResult(lt, j, i))
            ACS_NamedExecuteWithResult(cb_swap, j, i);
}
*/

function void ACSUtils_heap_sort(int begin, int end, str lt, str cb_swap)
{
    if(begin >= end) return;
    int heap_size;
    
    // Since the supplied comparison function is a min function, we build a max heap to finally cb_swap the max with the last element in the array range
    ACSUtils_build_max_heap(begin, end, lt, cb_swap);
    
    // At this point in execution the heap size will be >= 2
    do
    {
        // Protip: use ExecuteWithResult even when ur not expecting a result, otherwise the execution order will be fucked up if a script is called from inside a function (i almost ragequit acs again until i figured this out)
        //Log(s:"Imma cb_swap yo momma");
        ACS_NamedExecuteWithResult(cb_swap, begin, end);
        heap_size = --end - begin + 1;
        
        // There's only a single violation of the max-heap property - at the root of the entire heap, from now on
        ACSUtils_max_heapify(begin, begin, end, lt, cb_swap);
    }
    while(heap_size > 1);
}

// Reorders the entire array range to establish the max-heap invariant
function void ACSUtils_build_max_heap(int begin, int end, str lt, str cb_swap)
{
    // i = n/2 downto 1 inclusive, for arrays whose indexing is in range 1..n
    for(int i = begin + (end - begin) / 2; i >= begin; i--)
        ACSUtils_max_heapify(i, begin, end, lt, cb_swap);
}

// Corrects a single violation of the max-heap property at the given index, continuing to one of its subtrees after correction
function void ACSUtils_max_heapify(int index, int begin, int end, str lt, str cb_swap)
{
    // Implemented as 2 functions to avoid recursion, just in case of some acs shitrestriction
    do
    {
        index = ACSUtils_max_heapify_step(index, begin, end, lt, cb_swap);
    }
    while(index != -1);
}

// Returns index of the next subtree to be checked for the max-heap property and corrected; Returns -1 when done
function int ACSUtils_max_heapify_step(int index, int begin, int end, str lt, str cb_swap)
{
    int lchild = ACSUtils_heap_lchild(index, begin);
    int rchild = ACSUtils_heap_rchild(index, begin);
    
    // Check the max-heap property for the subtree rooted at _index_
    int max_i = index;
    if((lchild <= end) && ACS_NamedExecuteWithResult(lt, max_i, lchild))
        max_i = lchild;
    if((rchild <= end) && ACS_NamedExecuteWithResult(lt, max_i, rchild))
        max_i = rchild;
    if(max_i != index)
    {
        ACS_NamedExecuteWithResult(cb_swap, index, max_i);
        return max_i;
    }
    return -1;
}

// Heap node children index functions
function int ACSUtils_heap_lchild(int index, int begin)
{
    return begin + 2*(index - begin);
}

function int ACSUtils_heap_rchild(int index, int begin)
{
    return begin + 2*(index - begin) + 1;
}

// Contributed to ACSUtils by Konda

function void ShuffleArray(int begin, int end, str cb_swap)
{
	end--;
    for(int pick = begin; pick < end; pick++)
    {
        int index = random(pick, end);
        if(index != pick)
            ACS_NamedExecuteWithResult(cb_swap, pick, index);
    }
}

function void SyncVariable(int tid, int value)
{
	if (ClassifyActor(tid) == ACTOR_NONE)
	{
		if (!SpawnForced("ACSUtils_Sync", 0.0, 0.0, 0.0, tid))	
		{
			ACSUtils_ProgramError(StrParam
			(
				s:"Failed to spawn sync actor for tid ", d:tid, s:". ",
				s:"Make sure you copied \cjdecorate.acsutils \c-to your project."
			));
		}
	}
					
	SetActorProperty(tid, APROP_SPEED, value);
}

function int GetSyncVar(int tid)
{
	return GetActorProperty(tid, APROP_SPEED);
}

function int GetSyncVarDefault(int tid, int default_value)
{
	if (ClassifyActor(tid) == ACTOR_NONE)
		return default_value;
	return GetActorProperty(tid, APROP_SPEED);
}

// When adding new properties, don't forget to edit ACSUTILS_HUDSTATE_SIZE.
#define ACSUTILS_HUDLIB_SAVEDSTATES 16
#define ACSUTILS_HUDSTATE_SIZE 39
#define ACSUTILS_HUDLIB_STACKSIZE ACSUTILS_HUDSTATE_SIZE * ACSUTILS_HUDLIB_SAVEDSTATES



















































	

	



	
	





function void HudResetState(void)
{
	ACSUtils_Ints[52] = false;


	ACSUtils_Ints[19] = 0.0;
	ACSUtils_Ints[9] = 0.0;
	ACSUtils_Ints[40] = 0.0;
	ACSUtils_Ints[28] = 0.0;
	ACSUtils_Ints[11] = 0.0;

	ACSUtils_Ints[32] = 0.0;
	ACSUtils_Ints[15] = 0.0;
	ACSUtils_Ints[20] = 0.0;

	ACSUtils_Ints[12] = 0.0;
	ACSUtils_Ints[21] = 0.0;

	ACSUtils_Ints[42] = true;
	ACSUtils_Ints[17] = HUD_PROJECTION_AUTO;

	ACSUtils_Ints[23] = 640.0;
	ACSUtils_Ints[46] = 480.0;
	ACSUtils_Ints[45] = false;

	ACSUtils_Ints[41] = 0.0;
	ACSUtils_Ints[18] = 0.0;

	ACSUtils_Ints[30] = 1.0;
	ACSUtils_Ints[51] = 1.0;

	ACSUtils_Ints[37] = false;

	ACSUtils_Ints[5] = 0.0;
	ACSUtils_Ints[6] = HUD_STAYTIME_FOREVER;
	ACSUtils_Ints[48] = 0.0;

	ACSUtils_Ints[39] = HUD_BLENDSTYLE_NORMAL;
	ACSUtils_Ints[25] = 1.0;

	ACSUtils_Ints[24] = true;
	ACSUtils_Ints[50] = true;
	ACSUtils_Ints[34] = true;

	ACSUtils_Ints[27] = HUDMSG_LAYER_OVERHUD;

	ACSUtils_Ints[13] = HUD_ALIGN_CENTER;
	ACSUtils_Ints[49] = HUD_ALIGN_CENTER;
	ACSUtils_Ints[26] = false;
	ACSUtils_Strings[0] = "SMALLFONT";
	ACSUtils_Ints[1] = false;
	ACSUtils_Ints[3] = CR_UNTRANSLATED;
	ACSUtils_Ints[54] = false;
	ACSUtils_Ints[33] = false;
	ACSUtils_Ints[10] = false;
}

int HudStateStack[ACSUTILS_HUDLIB_STACKSIZE];

function void HudClearStateStack(void)
{
	ACSUtils_Ints[36] = 0;
}

function void HudPushState(void)
{
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[52];


	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[19];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[9];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[40];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[28];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[11];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[32];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[15];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[20];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[12];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[21];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[42];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[17];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[23];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[46];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[45];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[41];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[18];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[30];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[51];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[37];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[5];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[6];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[48];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[39];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[25];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[24];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[50];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[34];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[27];

	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[13];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[49];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[26];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Strings[0];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[1];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[3];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[54];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[33];
	HudStateStack[ACSUtils_Ints[36]++] = ACSUtils_Ints[10];
	
	if (ACSUtils_Ints[36] > ACSUTILS_HUDLIB_STACKSIZE)
		ACSUtils_LimitError("HudPushState(): state stack overflow.");
}

function void HudPopState(void)
{
	if (ACSUtils_Ints[36] == 0)
	{
		ACSUtils_ProgramError("HudPopState() called with no saved state.");
		return;
	}

	ACSUtils_Ints[10] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[33] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[54] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[3] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[1] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Strings[0] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[26] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[49] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[13] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[27] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[34] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[50] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[24] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[25] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[39] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[48] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[6] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[5] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[37] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[51] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[30] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[18] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[41] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[45] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[46] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[23] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[17] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[42] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[21] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[12] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[20] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[15] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[32] = HudStateStack[--ACSUtils_Ints[36]];

	ACSUtils_Ints[11] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[28] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[40] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[9] = HudStateStack[--ACSUtils_Ints[36]];
	ACSUtils_Ints[19] = HudStateStack[--ACSUtils_Ints[36]];


	ACSUtils_Ints[52] = HudStateStack[--ACSUtils_Ints[36]];
	
	if (ACSUtils_Ints[36] < 0)
		ACSUtils_ProgramError("HudPushState/HudPopState are bugged. Report this bug to the acsutils project.");
}

function void HudSetCameraPosition(int x, int y, int z)
{
	ACSUtils_Ints[19] = x;
	ACSUtils_Ints[9] = y;
	ACSUtils_Ints[40] = z;
}

function void HudSetCameraAngles(int angle, int pitch)
{
	ACSUtils_Ints[28] = angle;
	ACSUtils_Ints[11] = pitch;
}

function void HudSetCameraVector(int x, int y, int z)
{
	VectorToAngles(x, y, z);
	ACSUtils_Ints[28] = r1;
	ACSUtils_Ints[11] = r2;
}


#libdefine HUD_CAMERAACTOR_NOPOSITION 1
#libdefine HUD_CAMERAACTOR_NOPREDICTION 2
#libdefine HUD_CAMERAACTOR_NODIRECTION 4
#libdefine HUD_CAMERAACTOR_NOVIEWHEIGHT 8

function void HudSetCameraActorAdvanced(int tid, int flags)
{
	if (!(flags & HUD_CAMERAACTOR_NOPOSITION))
	{
		int x = GetActorX(tid);
		int y = GetActorY(tid);
		int z = GetActorZ(tid);
		
		if (!(flags & HUD_CAMERAACTOR_NOVIEWHEIGHT))
			z += GetActorViewHeight(tid);
		
		if (!(flags & HUD_CAMERAACTOR_NOPREDICTION))
		{
			x -= GetActorVelX(tid);
			y -= GetActorVelY(tid);
			z -= GetActorVelZ(tid);
		}	
		
		HudSetCameraPosition(x, y, z);
	}
	
	if (!(flags & HUD_CAMERAACTOR_NODIRECTION))
		HudSetCameraAngles(GetActorAngle(tid), -GetActorPitch(tid));
}

function void HudSetCameraActor(int tid)
{
	HudSetCameraActorAdvanced(tid, 0);
}

function void HudSetPoint3D(int x, int y, int z)
{
	ACSUtils_Ints[52] = true;
	ACSUtils_Ints[32] = x;
	ACSUtils_Ints[15] = y;
	ACSUtils_Ints[20] = z;
}

function void HudSet2DOffset(int x, int y)
{
	ACSUtils_Ints[12] = x;
	ACSUtils_Ints[21] = y;
}

function void HudSetAutoDistanceScale(bool autoDistanceScale)
{
	ACSUtils_Ints[42] = autoDistanceScale;
}

function void HudSetProjectionMode(int mode)
{
	ACSUtils_Ints[17] = mode;
}

function void HudSetVirtualSize(int width, int height)
{
	ACSUtils_Ints[23] = width;
	ACSUtils_Ints[46] = height;
}

function void HudUseDefaultSize(void)
{
	ACSUtils_Ints[23] = 640.0;
	ACSUtils_Ints[46] = 480.0;
}

function void HudUseRealSize(void)
{
	ACSUtils_Ints[23] = (GetScreenWidth()<<16);
	ACSUtils_Ints[46] = (GetScreenHeight()<<16);
}

function int HudBorderX(void)
{
	return HudBorderXFor(ACSUtils_Ints[23]);
}

function int HudBorderY(void)
{
	return HudBorderXFor(ACSUtils_Ints[46]);
}

function int HudLeft(void)
{
	return HudLeftFor(ACSUtils_Ints[23]);
}
function int HudX1(void)
{
	return HudX1For(ACSUtils_Ints[23]);
}

function int HudRight(void)
{
	return HudRightFor(ACSUtils_Ints[23]);
}
function int HudX2(void)
{
	return HudX2For(ACSUtils_Ints[23]);
}

function int HudTop(void)
{
	return HudTopFor(ACSUtils_Ints[46]);
}
function int HudY1(void)
{
	return HudY1For(ACSUtils_Ints[46]);
}

function int HudBottom(void)
{
	return HudBottomFor(ACSUtils_Ints[46]);
}
function int HudY2(void)
{
	return HudY2For(ACSUtils_Ints[46]);
}

function void HudSetExcludeStatusBar(bool exclude)
{
	ACSUtils_Ints[45] = exclude;
}

function void HudSetPoint(int x, int y)
{
	ACSUtils_Ints[52] = false;
	ACSUtils_Ints[41] = x;
	ACSUtils_Ints[18] = y;
}

function void HudSetScaleXY(int scaleX, int scaleY)
{
	if (scaleX != 0.0)
		ACSUtils_Ints[30] = FixedDiv(1.0, scaleX);
	else
		ACSUtils_Ints[30] = 0.0;
	
	if (scaleY != 0.0)
		ACSUtils_Ints[51] = FixedDiv(1.0, scaleY);
	else
		ACSUtils_Ints[51] = 0.0;
}

function void HudSetScale(int scale)
{
	HudSetScaleXY(scale, scale);
}

function void HudSetInvScale(int invScale)
{
	ACSUtils_Ints[30] = invScale;
	ACSUtils_Ints[51] = invScale;
}

function void HudSetInvScaleXY(int invScaleX, int invScaleY)
{
	ACSUtils_Ints[30] = invScaleX;
	ACSUtils_Ints[51] = invScaleY;
}

function void HudSetShowToEveryone(bool showToEveryone)
{
	ACSUtils_Ints[37] = showToEveryone;
}

function void HudSetAppearTime(int appearTime)
{
	ACSUtils_Ints[5] = appearTime;
}

function void HudSetStayTime(int stayTime)
{
	ACSUtils_Ints[6] = stayTime;
}

function void HudSetDisappearTime(int disappearTime)
{
	ACSUtils_Ints[48] = disappearTime;
}

function void HudSetBlendStyle(int style)
{
	ACSUtils_Ints[39] = style;
}

function void HudSetAlpha(int alpha)
{
	ACSUtils_Ints[25] = alpha;
}

function void HudSetShowIn3DView(bool show)
{
	ACSUtils_Ints[24] = show;
}

function void HudSetShowOnFullAutomap(bool show)
{
	ACSUtils_Ints[50] = show;
}

function void HudSetShowOnOverlayAutomap(bool show)
{
	ACSUtils_Ints[34] = show;
}

function void HudSetLayer(int layer)
{
	ACSUtils_Ints[27] = layer;
}

function void HudSetFont(str font)
{
	ACSUtils_Strings[0] = font;
}

function void HudSetTextColor(int textColor)
{
	ACSUtils_Ints[1] = false;
	ACSUtils_Ints[3] = textColor;
}

function void HudSetTextColorString(str textColor)
{
	ACSUtils_Ints[1] = true;
	ACSUtils_Ints[3] = textColor;
}

function void HudSetCenterText(bool centerText)
{
	ACSUtils_Ints[26] = centerText;
}

function void HudSetAlignment(int alignX, int alignY)
{
	ACSUtils_Ints[13] = alignX;
	ACSUtils_Ints[49] = alignY;
}

function void HudSetAlign(int alignX, int alignY)
{
	ACSUtils_Ints[13] = alignX;
	ACSUtils_Ints[49] = alignY;
}

function void HudSetAlignmentX(int alignX)
{
	ACSUtils_Ints[13] = alignX;
}

function void HudSetAlignX(int alignX)
{
	ACSUtils_Ints[13] = alignX;
}

function void HudSetAlignmentY(int alignY)
{
	ACSUtils_Ints[49] = alignY;
}

function void HudSetAlignY(int alignY)
{
	ACSUtils_Ints[49] = alignY;
}

function void HudSetTextTypeOn(bool textTypeOn)
{
	ACSUtils_Ints[54] = textTypeOn;
}

function void HudSetLogMessage(bool logMessage)
{
	ACSUtils_Ints[33] = logMessage;
}

function void HudSetWordWrap(bool wordWrap)
{
	ACSUtils_Ints[10] = wordWrap;
}

//int ACSUtils_Ints[14];
//int ACSUtils_Ints[44];
//int ACSUtils_Ints[22];

function bool ACSUtils_IsYShearing(void)
{
	if (ACSUtils_Ints[17] == HUD_PROJECTION_AUTO)
		return !IsOpenGL();
	
	return ACSUtils_Ints[17] == HUD_PROJECTION_YSHEARING;
}

// Rotate 3D point to view coordinate system.
function void ACSUtils_HudRotate3DPoint(void)
{
	// Translated point coordinates.
	int x = ACSUtils_Ints[32] - ACSUtils_Ints[19];
	int y = ACSUtils_Ints[15] - ACSUtils_Ints[9];
	int z = ACSUtils_Ints[20] - ACSUtils_Ints[40];

	int rx, ry, rz;
	int s, c;

	// Rotate around Z axis.
	s = sin(-ACSUtils_Ints[28]);
	c = cos(-ACSUtils_Ints[28]);
	rx = FixedMul(x, c) - FixedMul(y, s);
	ry = FixedMul(x, s) + FixedMul(y, c);
	x = rx; y = ry;

	// Rotate around Y axis.
	if (!ACSUtils_IsYShearing())
	{
		s = sin(-ACSUtils_Ints[11]);
		c = cos(-ACSUtils_Ints[11]);
		rx = FixedMul(x, c) - FixedMul(z, s);
		rz = FixedMul(x, s) + FixedMul(z, c);
		x = rx; z = rz;
	}

	ACSUtils_Ints[14] = x;
	ACSUtils_Ints[44] = y;
	ACSUtils_Ints[22] = z;
}

function int HudGetDistance(void)
{
	ACSUtils_HudRotate3DPoint();
	return ACSUtils_Ints[14];
}


#libdefine CAMERA_BASE_DISTANCE 128

function void ACSUtils_HudDrawHudMessage(int id, int type, str text, bool isText)
{
	if (ACSUtils_Ints[30] == 0 || ACSUtils_Ints[51] == 0)
		return;

	type |= ACSUtils_Ints[27];
	if (!ACSUtils_Ints[24])
		type |= HUDMSG_NOTWITH3DVIEW;
	if (!ACSUtils_Ints[50])
		type |= HUDMSG_NOTWITHFULLMAP;
	if (!ACSUtils_Ints[34])
		type |= HUDMSG_NOTWITHOVERLAYMAP;
	
	if (ACSUtils_Ints[39] == HUD_BLENDSTYLE_ADDITIVE)
		type |= HUDMSG_ADDBLEND;
	else if (ACSUtils_Ints[25] != 1.0)
		type |= HUDMSG_ALPHA;

	int x = ACSUtils_Ints[41];
	int y = ACSUtils_Ints[18];
	int iScaleX = ACSUtils_Ints[30];
	int iScaleY = ACSUtils_Ints[51];
	
	if (ACSUtils_Ints[52])
	{
		ACSUtils_HudRotate3DPoint();

		// Check if point is behind the camera.
		if (ACSUtils_Ints[14] <= 0)
		{
			ClearHudMessage(id);
			return;
		}
			
		// I don't know what this factor means, but it fixes positioning bugs.
		int yFactor = 1.6;
		if (StatusBarVisible())
			yFactor = 1.9;

		// Half heights.
		int hw = ((ACSUtils_Ints[23]) / 2);
		int hh = ((ACSUtils_Ints[46]) / 2);

		// Project point.
		x = -FixedDiv(ACSUtils_Ints[44], ACSUtils_Ints[14]);
		y = -FixedDiv(ACSUtils_Ints[22], ACSUtils_Ints[14]);
		
		if (ACSUtils_IsYShearing())
			y += tan(ACSUtils_Ints[11]);
		
		// Postprocess projected point.
		x += ACSUtils_Ints[12] + hw + FixedMul(hw, x);
		y += ACSUtils_Ints[21] + hh + FixedMul(FixedMul(hh, yFactor), y);
		///*
		//if (ACSUtils_Ints[42])
		//{
			iScaleX = FixedMul(iScaleX, ACSUtils_Ints[14] / CAMERA_BASE_DISTANCE / 4);
			iScaleY = FixedMul(iScaleY, ACSUtils_Ints[14] / CAMERA_BASE_DISTANCE / 4);
		//}
		//*/
	}
	
	int w = FixedMul(ACSUtils_Ints[23], iScaleX);
	int h = FixedMul(ACSUtils_Ints[46], iScaleY);
	SetHudSize(itrunc(w), itrunc(h), !(ACSUtils_Ints[52] || ACSUtils_Ints[45]));
	
	x = trunc(FixedMul(x, iScaleX));
	y = trunc(FixedMul(y, iScaleY));
	
	if (ACSUtils_Ints[13] == HUD_ALIGN_LEFT)
		x += 0.1;
	else if (ACSUtils_Ints[13] == HUD_ALIGN_RIGHT)
		x += 0.2;
		
	if (ACSUtils_Ints[49] == HUD_ALIGN_TOP)
		y += 0.1;
	else if (ACSUtils_Ints[49] == HUD_ALIGN_BOTTOM)
		y += 0.2;
		
	if (ACSUtils_Ints[26])
		x += 0.4;
	
	// BUG: this really simplifies the code, but the messages will only stay
	// for 9 hours.
	int stayTime = ACSUtils_Ints[6];
	if (stayTime < 0.0)
		stayTime = FIXED_MAX;
	
	if (ACSUtils_Ints[37])
	{
		HudMessageBold(s:text;
			type,
			id,
			ACSUtils_Ints[3],
			x, y,
			stayTime, ACSUtils_Ints[5], ACSUtils_Ints[48],
			ACSUtils_Ints[25]
		);
	}
	else
	{
		HudMessage(s:text;
			type,
			id,
			ACSUtils_Ints[3],
			x, y,
			stayTime, ACSUtils_Ints[5], ACSUtils_Ints[48],
			ACSUtils_Ints[25]
		);
	}
}

function void HudDrawText(int id, str text)
{
	int type = HUDMSG_FADEINOUT;
	if (ACSUtils_Ints[5] > 0 && ACSUtils_Ints[54])
		type = HUDMSG_TYPEON;
	
	if (ACSUtils_Ints[33])
		type |= HUDMSG_LOG;
	if (ACSUtils_Ints[1])
		type |= HUDMSG_COLORSTRING;
	if (!ACSUtils_Ints[10])
		type |= HUDMSG_NOWRAP;

	SetFont(ACSUtils_Strings[0]);
	ACSUtils_HudDrawHudMessage(id, type, text, true);
}

function void HudDrawImage(int id, str image)
{
	SetFont(image);
	ACSUtils_HudDrawHudMessage(id, HUDMSG_FADEINOUT, "A", false);
}

bool scanneractive = false;
int AreaTidTracker[7] = {
0,
0,
0,
0,
0,
0,
0,
};

function void areascandraw(int id, str image, int layer)
{
If(thingcount(t_none, id) > 0)
{
//hudsetautodistancescale (true);
HudResetState();
		HudSetPoint3D(getactorx(id), getactory(id), getactorz(id));
		HudSetCameraActor(0); // Set HUD Library camera to match the activator
		HudDrawimage(layer, image);
		}
		Else
		{
		
		clearhudmessage(layer);
		}

}

Script "areascantid" (int trackerorder) NET
{
	If(activatortid() == 0)
	{
	thing_changetid(0,uniquetid(1660,666));
	}
	Areatidtracker[trackerorder] =  activatortid();

}

Script "areascan" (VOID) NET
{
scanneractive = true;
takeinventory("powerareascan",1);
giveinventory("powerareascan",1);
playsound(0,"areascanner",122);
int scantimer = 0;
int i = 128;

	Until ( scantimer >= i )
		{
		areascandraw(Areatidtracker[0], "SCANKEY", 1660);
		areascandraw(Areatidtracker[1], "SCANKEY", 1661);
		areascandraw(Areatidtracker[2], "SCANKEY", 1662);
		areascandraw(Areatidtracker[3], "SCANSKL", 1663);
		areascandraw(Areatidtracker[4], "SCANSKL", 1664);
		areascandraw(Areatidtracker[5], "SCANSKL", 1665);
		areascandraw(Areatidtracker[6], "SCANMAP", 1666);
		
		Delay(1);
		scanTimer = (scantimer + 1);
		}
		scanneractive = false;
		clearhudmessage(1660);
		clearhudmessage(1661);
		clearhudmessage(1662);
		clearhudmessage(1663);
		clearhudmessage(1664);
		clearhudmessage(1665);
		clearhudmessage(1666);

}
/*
Script "AreascanCleanup" ENTER
{
If(!scanneractive)
{
clearhudmessage(-Areatidtracker[0]);
		clearhudmessage(-Areatidtracker[1]);
		clearhudmessage(-Areatidtracker[2]);
		clearhudmessage(-Areatidtracker[3]);
		clearhudmessage(-Areatidtracker[4]);
		clearhudmessage(-Areatidtracker[5]);
		clearhudmessage(-Areatidtracker[6]);
		}
Delay(1);
RESTART;
}
*/