
class Brutal_PlayerBase : PlayerPawn
{
	//=========================
	//Common
	//Movement General
	bool	Pain;
	double	ViewAngleDelta;
	float	ActualSpeed;
	float	MaxAirSpeed;
	float 	MaxGroundSpeed;
	float	MoveFactor;
	int		AnimateJump;
	int		ForceVelocity;
	int		MoveType;
	int		OldFloorZ;
	playerinfo ZMPlayer;
	vector2 OldVelXY;
	vector3	Acceleration;
	bool	Bsprinting;
	bool exhausted;
	
	//////////////////
	
	//Jumping
	bool 	BlockJump;
	bool	Jumped;
	bool	doublejumpready;
	bool	alreadyjumped;
	bool	oldjump;
	float	FloorAngle;
	int		DoubleJumpCooler;
	int		JumpSoundCooler;
	int		jumpcooler;
	
	//Double Jump
	bool	BlockDoubleJump;
	bool	CanDoubleJump;
	
	//Elevator Jumps
	float	ElevatorJumpBoost;
	int		OldSecIndex;
	
	//////////////////
	
	//Double Tap
	int		FirstTapTime;
	int		FirstTapValue;
	int		OldTapValue;
	
	//Dashing
	float	WJumpSpeed;
	int		DashNumber;
	int		DashCooler;
	
	//Air Dashing
	float	ADashTargetSpeed;
	int		ADashCooler;
	int		ADashFrictionDelay;
	
	//WallJump
	int		CheckForWJump;
	
	//WallSlideMove
	bool	CanWSlide;
	int		CheckForWSlide;
	vector2	WSlideVelocity;
	
	//Crouch Slide
	bool	CanCSlide;
	float	MaximumSlideSpeed;
	float	QSlideDuration;
	int		CSlideStartTime;
	
	//Ledge Grabbing
	bool	LedgeGrabbed;
	float	LedgeAngle;
	int		LedgeHeight;
	bool	LedgeCheck;
	int		LedgeTime;
	int		LedgeHeightMax;
	int		LedgeHeightMin;
	float	FrameTime;
	double	velx;
	double	vely;
	double	velz;
	weapon	ReselectWeapon;
	
	//Grappling Hook
	actor	GrappledMonster;
	actor	HookFired;
	bool	Grappled;
	float	PendulumLength;
	vector3	GrappleVel;
	vector3 Rope;
	int grapplesidespeed;
	double lasttickrope;
	
	//Booster Frame
	int boosttics;
	float boostlevel;
	int forwardtics;
	double lasttickvellength;
	bool booster;
	bool boostersound;
	float oldmaxstepheight;
	
	//////////////////
	
	//View Bobbing
	bool	PostLandingBob;
	float	ZMBob;
	
	//Weapon bobbing
	bool	DoBob;
	double	BobTime;
	double	HorizontalSway;
	double	BobRange;
	double 	OldTicFrac;
	double	VerticalOffset;
	
	//=========================
	//Painkiller only
	
	//Movement
	bool	TrickFailed;
	float	AirControl;
	float	ActualMaxAirSpeed;
	
	//Jumping
	float	TrickJumpAngle;
	int		SmallerJumpHeight;
	
	//=========================
	//Build Engine Only
	
	//Movement
	bool	DeepWater;
	float	LandingVelZ;
	int		FVel;
	int		SVel;
	int		UVel;
	
	int		DualTimer;
	Int		SpecialTimer;
	Int		GrenadeTimer;
	
	//Jumping
	int		BuildJumpDelay;
	
	
	//Saved morph stuff
	int PreMorphArmor;
	float PreMorphArmorPercent;
	int PreMorphHealth;
	
	bool notvoodoo;
	bool previouschasecam;
	
	//Soul granting
	
	int previouskills;
	int currentkills;
	
	//Merciless Extermination
	
	bool mercilessgranted;
	
	
	//Flashlight
	
	bool flashon;
	int flashtimer;
	int flashburnout;
	
	//Skulls
	bool spawnwitharmor;
	bool spawnberserked;
	bool shockfactor;
	bool istactical;
	bool ischatterbox;
	bool oneupmanship;
	bool sequencebreak;
	bool maximumoverdrive;
	bool ultranightmare;
	int ultraseed;
	bool alreadyblacklisted;
	bool extralifegranted;
	bool reversalmodifier;
	bool triathlon;
	bool scoremaster;
	
	int killstreak;
	int killstreaktimer;
	
	bool scanneractive;
	int scannertimer;
	
	float lasttichealth;
	int paintimer;
	int healtimer;
	int geigertimer;
	
	//Shaders
	float quadtimer;
	float ragetimer;
	float radsuittimer;
	float hastetimer;
	float invtimer;
	
	//Taunts
	bool killtaunt;
	bool berserktaunt;
	int tauntcooldown;
	int taunttimer;
	int seetimer;
	bool newweapon;
	
	bool invehicle;
	
	//crosshair
	Actor aimActor_nearest; // Actor closest to aim;
	vector3 aimActor_anglesTo; // Angles to closest aimed at actor.
	vector3 aimActor_pos;
	Actor aimActor;
	vector3 aimpos;
	string crosshair;
	vector2 crosshairscale;
	int crosshairrange;
	
	Actor Visorlight;
	
	// List of weapons to be dropped because they were
	// picked up above max amount:
	array<Weapon> extraWeaponsToDrop;
	// List of weapons that were picked up from world
	// (updated from CanTouchItem()):
	array<Weapon> pickedUpWeapons;
	// Weapon we're focusing on (pressing Use will pick
	// it up):
	Weapon focusWeapon;
	// Text prompt to show for this weapon:
	String focusWeaponPrompt;
	// Will be set to true when pressing use to let
	// the weapon be picked up:
	bool manualPickup;
	
	// REPLACE WITH LANGUAGE STRINGS:
	const PICKUPSTR_SWAP = "Press Use to swap for \cg%s\c-";
	const PICKUPSTR_PICK = "Press Use to pick up \cg%s\c-";
	const PICKUPSTR_DW = "Press Use to dual wield \cg%s\c-"; 
	const MAXOWNEDWEAPONS = 4;
	
	Default
    {
		Player.DisplayName "Brutal Doom Player";
        PainChance 255;
    }
	
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////																						////
	//// Non-Movement Stuff																		////
	////																						////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	
	//Because GZDoom's Unit() returns NaN if a vector has no value
	vector3 SafeUnit3(Vector3 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	vector2 SafeUnit2(Vector2 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	
	// Counts all owned weapons:
	int CountOwnedWeapons()
	{
		array<Weapon> countedWeapons;
		for (Inventory item = inv; item; item = item.inv)
		{
			let weap = Weapon(item);
			// Count the weapon. You can add more conditions
			// to decide what should and shouldn't be counted:
			if (weap &&
				!weap.bPOWERED_UP && //skip sisterweapons
				!weap.bMELEEWEAPON && //skip Fist
				countedWeapons.Find(weap) == countedWeapons.Size() //skip already counted
				)
			{
				countedWeapons.Push(weap);
			}
		}
		return countedWeapons.Size();
	}
	
	// Returns true if the provided weapon would exceed weapon capacity
	// when picked up:
	bool ExceedsWeapCapacity(Weapon weap)
	{
		// Modify to add your own logic. Currently returns true
		// only if the given weapon is NOT dual-wieldable and
		// the number of already owned weapons is larger than
		// the given number:
		return !IsDualWieldable(weap) && TRIATHLON && (CountOwnedWeapons() >= MAXOWNEDWEAPONS);
	}
	
	void AddToPickupList(Weapon weap)
	{
		if (!weap) return;
		if (pickedUpWeapons.Find(weap) == pickedUpWeapons.Size())
		{
			pickedUpWeapons.Push(weap);
		}
	}
	
	void DropOwnedWeapon(Weapon weap)
	{
		if (!weap) return;
		if (weap.owner != self) return;
		
		self.DropInventory(weap, weap.amount);
		//let sis = weap.sisterweapon;
		//if (!sis || sis.owner != self) return;
		//self.DropInventory(sis, sis.amount);
	}
	
	// Check if the given weapon is dual-wieldable:
	bool IsDualWieldable(Weapon weap)
	{
		If(weap && weap.maxamount > 1 && countinv(weap.getclassname()) < 2 && countinv(weap.getclassname()) > 0)
		{
			return true;
		}
		Else
		{
			return false;
		}
	}
	
	// This override handles what happens when touching
	// an item:
	override bool CanTouchItem(Inventory item)
	{
		// If not weapon, do the usual:
		let weap = Weapon(item);
		if (!weap) return true;
	
		bool overCap = ExceedsWeapCapacity(weap);
		bool canDualWield = IsDualWieldable(weap);
		
		bool isfists;
		If(player.readyweapon && player.readyweapon is "Melee_attacks" && overcap && !isdualwieldable)
		{
			isfists = true;
		}
		
		bool isbarrel;
		If(player.readyweapon && !(player.readyweapon is "ExplosiveBarrelWeapon") && weap is "explosivebarrelweapon")
		{
			isbarrel = true;
		}
	
		// Collision boxes not overlapping - this is being picked
		// up elsewhere, by a voodoo doll. Let voodoo dolls pick up
		// weapons directly:
		if (distance3d(weap) > 128 && !(weap is "ExplosiveBarrelWeapon"))
		{
			AddToPickupList(weap);
			return true;
		}
		
		// If this is a weapon we're already getting a promopt about,
		// and player pressed Use, pick it up:
		if (weap == focusWeapon && manualPickup && !isfists && !isbarrel)
		{
			// if over capacity, drop readyweapon:
			if (overCap)
			{
				DropOwnedWeapon(self.player.readyweapon);
				player.pendingweapon = focusWeapon;
			}
			// if dual-wieldable, activate that:
			if (canDualWield)
			{
				A_selectweapon(weap.getclassname());
			}
			// and flush the pointer:
			focusWeapon = null;
			manualPickup = false;
			AddToPickupList(weap);
			return true;
		}
		
		
		if (weap == focusWeapon && manualPickup && isbarrel)
		{
			// and flush the pointer:
			focusWeapon = null;
			manualPickup = false;
			AddToPickupList(weap);
			return true;
		}
		// If we're here, we're NOT picking this weapon up,
		// so, it's time to process it.
		
		// First, unconditionally pick up ammo from the weapon:
		class<Ammo> amcls;
		int amtToGive; //how much ammo will be given
		for (int i = 1; i <= 2; i++)
		{
			// Initially set amtToGive to ammogive:
			if (i == 1)
			{
				amcls = weap.ammoType1;
				amtToGive = weap.ammoGive1;
			}
			else
			{
				amcls = weap.ammoType2;
				amtToGive = weap.ammoGive2;
			}

			if (!amcls) continue;
			// If player has this ammo, instead set amtToGive to
			// make sure it doesn't exceed current maxamount:
			Ammo am = Ammo(self.FindInventory(amcls));
			if (am)
			{
				amtToGive = min(amtToGive, am.maxamount - am.amount);
			}
			// If amount-to-give is above 0, do the giving:
			if (amtToGive > 0)
			{
				// We want the accompanying sound and pickupmessage
				// to appear, so we'll actually spawn that ammo,
				// modify its amount, and give it to the player
				// directly by calling Touch() on it:
				let amPickup = Ammo(Spawn(amcls, (0,0,0)));
				if (amPickup)
				{
					amPickup.amount = amtToGive;
					amPickup.bIGNORESKILL = true;
					amPickup.Touch(self);
			
					// Reduce that weapon's ammogive by the amount of ammo
					// we've given (so it doesn't become an endless
					// source of ammo):
					if (i == 1)
					{
						weap.ammoGive1 -= amtToGive;
					}
					else
					{
						weap.ammoGive2 -= amtToGive;
					}
				}
			}
		}
		
		// If weapon is already owned and is not dual-wieldable,
		// nothing else needs to happen:
		if (self.FindInventory(weap.GetClass()) && !canDualWield  || ISFISTS && !IsBarrel || IsBarrel && !self.FindInventory("PowerStrength"))
		{
			return false;
		}
		
		// Otherwise update prompt text and weapon pointer:
		focusWeaponPrompt = PICKUPSTR_PICK; //base prompt
		if (canDualWield)
		{
			focusWeaponPrompt = PICKUPSTR_DW; //dual-wield prompt
		}
		else if (overCap && !isbarrel) //we're at capacity
		{
			focusWeaponPrompt = PICKUPSTR_SWAP; //swap prompt
		}
		// Construct the prompt (this assumes "%s" is present to pass
		// the name of the weapon to, and calls StringTable.Localize
		// so it'll be correctly localized if LANGUAGE is used):
		focusWeaponPrompt = String.Format(StringTable.Localize(focusWeaponPrompt), weap.GetTag());
		
		focusWeapon = weap;
		return false;
	}
	
	override bool CanReceive(Inventory item)
	{
		let weap = Weapon(item);
		if (weap)
		{
			AddToPickupList(weap);
		}
		return true;
	}
	
	// Called when an item is received:
	override void HasReceived(Inventory item, class<Inventory> itemcls)
	{
		if (BDPHandler.IsVoodooDoll(self)) return;
		
		let weap = Weapon(item);
		if (!weap) return;
		

		// If it was in the picked-up list, remove it from there:
		int id = pickedUpWeapons.Find(weap);
		if (id < pickedUpWeapons.Size() && TRIATHLON && (CountOwnedWeapons() > MAXOWNEDWEAPONS))
		{
			DropOwnedWeapon(weap);
			pickedUpWeapons.Delete(id);
		}
		// If it was the focus weapon, flush the pointer:
		if (weap == focusWeapon)
		{
			focusWeapon = null;
		}
	}
	void togglescanner()
	{
		If(!scanneractive)
		{
			scanneractive = true;
			a_startsound("areascanner",122);
			//spawn("scannereffect",pos);
			
		}
		Scannertimer = 130;

	}
	
	void tauntthink()
	{
		If(tauntcooldown)
		{
			tauntcooldown--;
		}
		If(taunttimer)
		{
			taunttimer--;
		}
		If(seetimer)
		{
			seetimer--;
		}
		If(!tauntcooldown)
		{
			If(killtaunt && taunttimer < 1)
			{
				killtaunt = false;
				tauntcooldown = 105;
				A_startsound("DGKILL",455,CHANF_NOSTOP);
			}
			If(berserktaunt)
			{
				berserktaunt = false;
				tauntcooldown = 105;
				A_startsound("DGBRSK",455,CHANF_NOSTOP);
			}
		
		}
		
		If(random(1,35) == 1 && !seetimer && !tauntcooldown)
		{
			//console.printf("scanned");
			bool seenmonster;
			bool seencyber;
			int seenmonstercount;
			int cacocount;
			
			BlockThingsIterator CheckForTargets = BlockThingsIterator.create(Self,1000); //256 can be whatever range around the actor.
			Actor CurrentActor; //A pointer to whatever actor the iterator is iterating through.
			While (CheckForTargets.Next()) 
			{
				CurrentActor = CheckForTargets.Thing;
				//If the actor is a monster, has none of the specified item, the caller has a line of sight to the actor, and the actor is within 512 MU, then jump to the see state.
				//Itemname obviously has to be whatever item you want the actor to check that the possible target has none of, and the 512 map unit sight range can be changed to anything else.
				If (CurrentActor && CurrentActor.bIsMonster && !currentactor.bfriendly  && CheckSight(CurrentActor,SF_IGNOREWATERBOUNDARY) && currentactor != self && !(currentactor is "explosivebarrel1") && currentactor.health > 0 && !currentactor.findinventory("youveseenme"))
				{
					vector3 targetpos = LevelLocals.SphericalCoords((pos.x,pos.y,player.viewz),currentactor.pos+(0,0,currentactor.default.height*0.5),(angle,pitch));    
					if (abs(targetpos.x) <= 20 && abs(targetpos.y) <= 20)
					{
						//console.printf(currentactor.getclassname());
						seenmonster = true;
						seenmonstercount++;
						//HACKY AS HELL!!!
						currentactor.giveinventory("youveseenme",1);
						if(currentactor is "Cacodemon" || currentactor is "PainElemental1")
						cacocount++;
						if(currentactor is "Cyberdemon")
						seencyber = true;
					}
				}
			}
			If(seencyber)
			{
				A_startsound("DGCYB",455,CHANF_NOSTOP);
				seetimer = random(350,3500);
				tauntcooldown = 105;
			}
			Else If(seenmonster && cacocount > 2 && random(1,3) == 1)
			{
				A_startsound("DGCACO",455,CHANF_NOSTOP);
				seetimer = random(350,3500);
				tauntcooldown = 105;
			}
			Else If(seenmonster && seenmonstercount > 2)
			{
				A_startsound("DGSEE",455,CHANF_NOSTOP);
				seetimer = random(350,3500);
				tauntcooldown = 105;
			}
		}
		If(!tauntcooldown && !taunttimer && newweapon)
		{
			newweapon = false;
			tauntcooldown = 105;
			If(player.readyweapon)
			{
				If(player.readyweapon is "Chain_Saw")
				{
					A_startsound("DGCSAW",455);
				}
				else if(player.readyweapon is "BIG_FUCKING_GUN")
				{
					A_startsound("DGBFG",455);
				}
				else if(player.readyweapon is "PLASMA_GUN")
				{
					A_startsound("DGPLAS",455);
				}
				else if(player.readyweapon is "MiniGun")
				{
					A_startsound("DGCGUN",455);
				}
				else if(player.readyweapon is "BrutalSMG")
				{
					A_startsound("DGSMG",455);
				}
				else if(player.readyweapon is "DoxsRevolver")
				{
					A_startsound("DGREV",455);
				}
				else if(player.readyweapon is "Unmaker")
				{
					A_startsound("DGUNM",455);
				}
				else if(player.readyweapon is "Rocket_Launcher")
				{
					A_startsound("DGROCK",455);
				}
				else if(player.readyweapon is "AssaultShotgun")
				{
					A_startsound("DGAUTO",455);
				}
				else if(player.readyweapon is "rifle")
				{
					A_startsound("DGASS",455);
				}
				else if(player.readyweapon is "incinerator")
				{
					A_startsound("DGFLAM",455);
				}
				else if(player.readyweapon is "Shot_gun" || player.readyweapon is "SSG")
				{
					A_startsound("DGSGUN",455);
				}
				Else
				{
					A_startsound("DGITEM",455);
				}
			
			}
		}
	}
	
	override void PlayerLandedMakeGruntSound(actor onmobj)
	{
		bool grunted;

		// [RH] only make noise if alive
		if (self.health > 0 && !Alternative)
		{
			grunted = false;
			// Why should this number vary by gravity?
			if (self.Vel.Z < -10)
			{
				let jumpland = spawn("BDPLANDED",pos);
				
				If(jumpland)
				{
					jumpland.tracer = self;
				}
				
				grunted = true;
			}
		}
	}
	
	Override int takespecialdamage(Actor inflictor, Actor source, int damage, Name damagetype)
		{
			If(inflictor is "grenadeexplosion" && source == self || inflictor is "leadburstertracer2")
			{
				Damage = (damage * 0.25);
			}
			If(source is "BDPBIKE" && !invehicle)
				{
					damage = 0;
					SetStateLabel("pain.bikelaunch");
					
				}
			If(source is "Freezerbot" || source is "FreezeBot" || inflictor is "FreezeBot" || Inflictor is "Freezerbot")
				{
					damage = 0;
					
				}
			If(grappled)
				{
					Damage = (damage * 0.25);
				}
				
			return super.TakeSpecialDamage(inflictor, source, damage, damagetype);
				
		
		
		}
	
	Override void playerthink()
		{
		Super.playerthink();
		
		
		
		if (findinventory("BDPInvuln"))
            {
                PPShader.SetEnabled("tempinv", true);
				invtimer = 1.0;
				PPShader.SetUniform1f("tempinv","intensity",invtimer);
            }
            else If(invtimer > 0)
            {
                invtimer -= 0.04;
				PPShader.SetUniform1f("tempinv","intensity",invtimer);
            }
		if (findinventory("PowerIronFeet"))
            {
                PPShader.SetEnabled("radsuit", true);
				radsuittimer = 0.15;
				PPShader.SetUniform1f("radsuit","intensity",radsuittimer);
            }
            else If(radsuittimer > 0)
            {
                radsuittimer -= 0.01;
				PPShader.SetUniform1f("radsuit","intensity",radsuittimer);
            }
		if (findinventory("PowerSpeed2"))
             {
                PPShader.SetEnabled("haste", true);
				hastetimer = 0.30;
				PPShader.SetUniform1f("haste","intensity",hastetimer);
            }
            else If(hastetimer > 0)
            {
                hastetimer -= 0.01;
				PPShader.SetUniform1f("haste","intensity",hastetimer);
            }
		if (findinventory("PowerRage"))
            {
                PPShader.SetEnabled("rage", true);
				ragetimer = 0.30;
				PPShader.SetUniform1f("rage","intensity",ragetimer);
            }
            else If(ragetimer > 0)
            {
                ragetimer -= 0.01;
				PPShader.SetUniform1f("rage","intensity",ragetimer);
            }
		if (findinventory("PowerQuakeDamage"))
            {
                PPShader.SetEnabled("quad", true);
				quadtimer = 0.30;
				PPShader.SetUniform1f("quad","intensity",quadtimer);
            }
            else If(quadtimer > 0)
            {
                quadtimer -= 0.01;
				PPShader.SetUniform1f("quad","intensity",quadtimer);
            }
		
		
		//Health Regen
		//console.printf("%i",health);	
		If(paintimer > 0)
		{
			paintimer--;
		}
		If(health < lasttichealth)
		{
			paintimer = 180;
			healtimer = 0;
		}
		lasttichealth = health;
		If(paintimer <= 0 && healtimer < 8)
		{
			healtimer++;
		}
		If(healtimer >= 8 && health < 20 && health > 0)
		{
			A_sethealth(health + 1);
			healtimer = 0;
		}
			
		
		takeinventory("PausePowerup",1);
		
		If(health >= 1)
		{
			If(ischatterbox)
			{
				TauntThink();
			}
			
			
			If(scannertimer > 0)
			{
				scannertimer--;
			}
			Else
			{
				scanneractive = false;
			}
			If(flashtimer > 0)
			{
				flashtimer--;
			}
			
			If(flashburnout > 0 && !findinventory("powernightvisneo"))
			{
				flashburnout--;
			}
			
			If(findinventory("switchflashlight"))
			{
				If(flashon && !flashtimer)
				{
					flashtimer = 20;
					flashon = false;
					If(!findinventory("powernightvisneo"))
					{
						A_startsound("FLASHOFF",5);
					}
					else
					{
						A_startsound("INFRAOFF",5);
					}
					A_takeinventory("BDP_flashlight",1);
					
					//PPShader.SetEnabled("NiteVis",false);

				}
				Else if(!flashtimer)
				{
					flashtimer = 20;
					flashburnout = 700;
					flashon = true;
					If(!findinventory("powernightvisneo"))
					{
						A_startsound("FLASHON",5);
					}
					else
					{
						A_startsound("INFRAON",5);
					}
					A_giveinventory("BDP_flashlight",1);
					//PPShader.SetEnabled("NiteVis",true);
				}
				Takeinventory("switchflashlight",1);
			}
			
			If(flashon && !flashburnout)
				{
					flashon = false;
					A_startsound("FLASHOFF",5);
					A_takeinventory("BDP_flashlight",1);
					flashtimer = 20;
					Takeinventory("switchflashlight",1);
				}
				
			If(findinventory("powernightvisneo") && flashon)
				{
					PPShader.SetEnabled("NiteVis",true);
					
					
				}
			Else
				{
					PPShader.SetEnabled("NiteVis",false);
					
				}
			
		
			
			
		}
		//geiger counter
			If(CurSector.DamageAmount != 0)
			{
				If(geigertimer <= 0)
				{
					geigertimer = (pos.z - getzat());
					geigertimer *= 0.04;
					If(geigertimer < 0)
					{
						geigertimer *= -1;
					}
					geigertimer = clamp(geigertimer, 1, 20);
					
					geigertimer += random(-1,2);
					
					//console.printf("%i",geigertimer);
					a_startsound("GEIGER",102,0);
				}
				
				
				
			}
			
			If(geigertimer > 0)
			{
				geigertimer--;
			}
		
		
		If(killstreak)
		{
			killstreaktimer--;
		}
		
		If(killstreaktimer <= 0)
		{
			killstreak = 0;
		}
		
		currentkills = Level.Killed_monsters;
		If(currentkills > previouskills)
		{
			giveinventory("soulammo",(currentkills - previouskills));
			//console.printf("Soul Extracted");
		}
		previouskills = Level.Killed_monsters;
		
		
		
		If(currentkills == 0)
		{
			mercilessgranted = false;
		}
		If(!mercilessgranted && currentkills > 5 && currentkills >= Level.Total_Monsters)
		{
			mercilessgranted = true;
			A_Print("MERCILESS EXTERMINATION!",5);
			If(health < 100)
			{
				A_sethealth(100);
			}
			A_startsound("ALLKILL",227,CHANF_LOCAL,1.0,ATTN_NONE);
			If(random(0,50) == 5)
			{
				A_startsound("YIPPEE",228,CHANF_LOCAL,1.0,ATTN_NONE);
			}
			
		}
		
		If(ultranightmare && !ultraseed)
		{
		
			string data = bdp_seed_blacklist;
			Array<string> blacklist;
			data.Split(blacklist,",");
			
			int ultraseedcandidate = random(1,99999999999);
			bool candidatetaken;
			for(int i=0; i<blacklist.Size(); i++)
			{	
				int blacklistint = (blacklist[i].ToInt(10));
				//console.printf("%i",blacklistint);
				If(blacklistint == ultraseedcandidate)
				{
					candidatetaken = true;
				}
			
			}
			If(!candidatetaken)
			{
				ultraseed = ultraseedcandidate;
				//console.printf("%i",ultraseed);
			}
				
			
		}
		
		if(ultraseed)
		{
			
			If((health < 1) && !alreadyblacklisted)
			{
				A_Print("\cgThe nightmare has ended.",999);
				ACS_NamedExecuteAlways("BDNightmareDeath", 0, 0, 0, 0);
				string ultraseedstring = (string.format("%i", ultraseed));
				//Console.printf(ultraseedstring);
				let sv_blacklist = CVar.GetCVar("bdp_seed_blacklist", players[consoleplayer]);

				if(bdp_seed_blacklist == "") 
				sv_blacklist.SetString(ultraseedstring);
				else
				sv_blacklist.SetString(String.Format("%s, %s", bdp_seed_blacklist, ultraseedstring));
				//console.printf("%s, %s", bdp_seed_blacklist, ultraseedstring);
				Alreadyblacklisted = true;
			}
			
			
			If((health >= 1))
			{
				string data = bdp_seed_blacklist;
				Array<string> blacklist;
				data.Split(blacklist,",");
				for(int i=0; i<blacklist.Size(); i++)
				{	
					int blacklistint = (blacklist[i].ToInt(10));
					//console.printf("%i",blacklistint);
					If(blacklistint == ultraseed)
					{
						//candidatetaken = true;
						damagemobj(null,null,9999999,"explosiveimpact");
						A_Print("\cgThe nightmare has ended.",999);
						ACS_NamedExecuteAlways("BDNightmareLoad", 0, 0, 0, 0);
						//S_ChangeMusic("ORB");
						Alreadyblacklisted = true;
						//console.printf("FAGGOT");
					}
			
				}
			}
			
		}	
		
		if(ultranightmare && oneupmanship && !findinventory("UltraBonus"))
		{
			A_giveinventory("extralife",3);
			A_giveinventory("ultrabonus",1);
		}
		
		If(spawnwitharmor && !findinventory("powershield",TRUE) && health > 0)
		{
			GiveInventory("PowerShield2",1);
			If(countinv("basicarmor") < 50)
			{
				takeinventory("basicarmor",50);
				GiveInventory("mjolnirarmor",50);
			}
		}
		
		If(spawnberserked && !findinventory("powerstrength",TRUE) && health > 0)
		{
			GiveInventory("Berserk2",1);
			If((health) < 50)
			{
				a_sethealth(100);
			}
		}
		
		If(maximumoverdrive && !findinventory("powerboost",TRUE) && health > 0)
		{
			GiveInventory("boosterframe",1);
		}
		
		If(sequencebreak && !findinventory("sequencebreaker"))
		{
			GiveInventory("SequenceBreaker",1);
		}
		
		
		If(shockfactor && level.time % 5 == 0)
		{
			A_alertmonsters(0,AMF_TARGETEMITTER);
		}
		
		If(reversalmodifier && !findinventory("canparry",TRUE) && health > 0)
		{
			GiveInventory("canparry",1);
		}
		
		If(countinv("extralife") > 0)
		{
			bbuddha = true;
			If((health) <= 1)
			{
				a_sethealth(100);
				A_takeinventory("extralife",1);
				A_giveinventory("miniinvul",1);
				A_startsound("items/soulsphere",212);
			}
		}
		Else
		{
			bbuddha = false;
		}
		
		//giveinventory("meathook",1);
		If (istactical)
		{
		Giveinventory("istacticalclass",1);
		Takeinventory("isnottacticalclass",1);
		}
		Else
		{
		Giveinventory("isnottacticalclass",1);
		Takeinventory("istacticalclass",1);
		}
		If(dualtimer >= 1)
		{
		Dualtimer = dualtimer - 1;
		}
		
		If(specialtimer >= 1)
		{
		Specialtimer = specialtimer - 1;
		}
		
		If(Grenadetimer >= 1)
		{
		Grenadetimer = Grenadetimer - 1;
		}
		
		If(health < 1)
		{
		A_stopsound(125);
		A_stopsound(126);
		}
		
		If(player.cmd.buttons & BT_USER3 && dualtimer <= 0)
			{
			dualtimer = 17;
			giveinventory("startdualwield",1);
			}

		If(player.cmd.buttons & BT_USER2 && grenadetimer <= 0)
			{
			grenadetimer = 8;
			giveinventory("TossGrenade",1);
			}
		If(player.cmd.buttons & BT_ATTACK)
			{
			giveinventory("firedprimary",1);
			}
			
			
	
		
		}
	
	
	Override void HandleMovement() { 
	
		
		notvoodoo = true;
		
		if(GetCvar("donotclimb") == 0) 
		{
			If(LedgeCheck)
			{
				if(countinv("usedstamina") < 60)
				{	
					LedgeReach();
				
				
				}
				Else
				{
					A_startSound("Tired", 21,CHANF_NOSTOP);
				}
			}
			if(LedgeGrabbed)
			{
				LedgeGrab();
			}
			LedgeGrabInitiator();
		}
		if(GetCVAR("donotdoublejump") == 0) 
		{
			//CheckJump();
		}
		if(GrappleVel.Length())
			{
				takeinventory("meathook",1);
				GrapplingMove();
			}
		Else
			{
				giveinventory("meathook",1);
				Grappled = False; 
			}
			
		super.HandleMovement();
		
	}
	
	override void moveplayer()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
		If(countinv("powerboost") > 0)
		{
			Booster = true;
		}
		Else
		{
			Booster = false;
		}
		
		
		If(countinv("usedstamina") >= 99)
		{
			exhausted = true;
		}
		Else if (countinv("usedstamina") < 60)
		{
			exhausted = false;
		}
		if (level.time % 2 == 0)
		{
			takeinventory("usedstamina",1);
	
		}
				
		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks)
		{
			player.turnticks--;
			Angle += (180. / TURN180_TICKS);
		}
		else
		{
			Angle += cmd.yaw * (360./65536.);
		}

		player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);

		// killough 10/98:
		//
		// We must apply thrust to the player and bobbing separately, to avoid
		// anomalies. The thrust applied to bobbing is always the same strength on
		// ice, because the player still "works just as hard" to move, while the
		// thrust applied to the movement varies with 'movefactor'.
		
		If(player.onground)
		{
			takeinventory("jetpackmoving",1);
		}
		
		Bool jetpacking = countinv("jetpackmoving");
		
		If(booster && bsprinting)
		{
			boosttics++;
			If(boosttics >= 10)
			{
				boostlevel++;
				boosttics = 0;
			}
		}
		Else if (boostlevel > 0)
		{
			boosttics++;
			If(boosttics >= 5)
			{
				boostlevel--;
				boosttics = 0;
			}
			If(!cmd.forwardmove)
			{
				forwardtics--;
				//console.printf("%i",forwardtics);
				If(forwardtics < -5)
				{
					boostlevel = 0;
					forwardtics = 0;
				}
			}
		}
		Else
		{
			boosttics = 0;
		}
		
		If (boostlevel > 5)
		{
			Boostlevel = 5;
		}
		
		//console.printf("%i",boostlevel);
		If(boostlevel >=3 && !boostersound)
		{
			Boostersound = true;
			A_startsound("BSTRSTRT",127);
			A_startsound("BSTRLoop",128,CHANF_LOOPING);
			//A_startsound("BSTRWind",129,CHANF_LOOPING);
			oldmaxstepheight = maxstepheight;
			maxstepheight = (maxstepheight * 2);
		}
		Else if (boostlevel < 3 && boostersound)
		{
			boostersound = false;
			A_StartSound("BSTRStop",127);
			A_stopsound(128);
			A_StopSound(129);
			maxstepheight = oldmaxstepheight;
		}
		
		if (cmd.forwardmove | cmd.sidemove)
		{
			double forwardmove, sidemove;
			double bobfactor;
			double friction, movefactor;
			double fm, sm;

			[friction, movefactor] = GetFriction();
			bobfactor = friction < ORIG_FRICTION ? movefactor : ORIG_FRICTION_FACTOR;
			bool inair;
			if (!player.onground && !bNoGravity && !waterlevel && !jetpacking && !rope.length())
			{
				// [RH] allow very limited movement if not on ground.
				movefactor *= 0.50;
				inair = true;
				bobfactor*= level.aircontrol;
			}
			If(rope.length())
			{
				bobfactor = 0;
			}

			fm = cmd.forwardmove;
			sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds (fm, sm);
			fm *= Speed / 256;
			sm *= Speed / 256;

			// When crouching, speed and bobbing have to be reduced
			if (CanCrouch() && player.crouchfactor != 1)
			{
				fm *= player.crouchfactor;
				sm *= player.crouchfactor;
				bobfactor *= player.crouchfactor;
				//Can't sprint while crouching
				Bsprinting = false;
			}
			//Check sprint
			else If((cmd.forwardmove || cmd.sidemove) && cmd.buttons & BT_SPEED)
			{
				If(!exhausted)
				{
					Bsprinting = true;
				}
				else
				{
					A_startSound("Tired", 21,CHANF_NOSTOP);
					bsprinting = false;
				}
			}
			Else
			{
				Bsprinting = false;
			}
		
			
			If(boostlevel >= 3)
			{
				fm *= 1.5;
				sm *= 1.5;
				//console.printf("%i",vel.length());
			}
			
			If(bsprinting)
			{
				fm = fm * 2;
				sm = sm * 2;
			}

			forwardmove = fm * movefactor * (35 / TICRATE);
			sidemove = sm * movefactor * (35 / TICRATE);
			
			//console.printf("Speed      : %010.5f u/s", forwardmove, DTA_HUDRules, true);
			
			If(!inair || rope.length())
			{
			
				if (forwardmove)
				{
					Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
					ForwardThrust(forwardmove, Angle);
				}
				if (sidemove)
				{
					let a = Angle - 90;
					Bob(a, cmd.sidemove * bobfactor / 256., false);
					Thrust(sidemove, a);
				}
				
			}
			else
			{
				//Console.printf("JUMPING");
				vector2 actualvelocity = rotatevector(vel.xy,-angle);
				if (forwardmove > 0 && actualvelocity.x < (forwardmove * 9.6))
				{
					Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
					ForwardThrust(forwardmove, Angle);
				}
				if (forwardmove < 0 && actualvelocity.x > (forwardmove * 9.6))
				{
					Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
					ForwardThrust(forwardmove, Angle);
				}
				
				if (sidemove > 0 && -actualvelocity.y < (sidemove * 9.6))
				{
					let a = Angle - 90;
					Bob(a, cmd.sidemove * bobfactor / 256., false);
					Thrust(sidemove, a);
				}
				if (sidemove < 0 && -actualvelocity.y > (sidemove * 9.6))
				{
					let a = Angle - 90;
					Bob(a, cmd.sidemove * bobfactor / 256., false);
					Thrust(sidemove, a);
				}
				
			}

			if (!(player.cheats & CF_PREDICTING) && (forwardmove != 0 || sidemove != 0))
			{
				PlayRunning ();
			}

			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
			
			If(jetpacking)
			{
				vel.xy *= 0.97;
			}
			
		}
		Else
		{
			Bsprinting = false;
		}
		
		If(boostlevel > 3 && !checkmove(Pos.XY + AngleToVector(angle, 16), PCM_NOACTORS))
		{
			
			A_stop();
			//A_recoil(14);
			//vel.z = 10;
			A_Quake(3,12,0,800);
			boostlevel = 0;
			boosttics = 0;
			A_startsound("skeleton/melee",28);
			
			
		}
		
		
		lasttickvellength = vel.length();
		
		If(boostlevel >= 3)
		{
			If(sequencebreak)
			{
				BDP_DoorBuster.DestroyDoor(self,  breakLocks: BDP_DoorBuster.LB_All);
			}
			Else
			{
				BDP_DoorBuster.DestroyDoor(self,  breakLocks: BDP_DoorBuster.LB_CheckKey);
			}
			a_spawnitemex("Speedline",140,frandom(40,-40),frandom(0,80),vel.x,vel.y,vel.z,0,SXF_ABSOLUTEVELOCITY);
			a_spawnitemex("Speedline",140,frandom(40,-40),frandom(0,80),vel.x,vel.y,vel.z,0,SXF_ABSOLUTEVELOCITY);
			a_spawnitemex("Speedline",140,frandom(40,-40),frandom(0,80),vel.x,vel.y,vel.z,0,SXF_ABSOLUTEVELOCITY);
			
			Actor speedMo = Spawn("PlayerSpeedTrail", Pos, NO_REPLACE);
			if (speedMo)
			{
				speedMo.Angle = Angle;
				speedMo.Translation = Translation;
				speedMo.target = Self;
				speedMo.sprite = sprite;
				speedMo.frame = frame;
				speedMo.Floorclip = Floorclip;

				// [BC] Also get the scale from the owner.
				speedMo.Scale = Scale;

				if (Self == players[consoleplayer].camera &&
					!(player.cheats & CF_CHASECAM))
				{
					speedMo.bInvisible = true;
				}
			}
		}
	
	}
	override void CheckJump()
	{
		
		let player = self.player;
		// [RH] check for jump
		If(!player.onground && !doublejumpready && !oldjump)
		{
			doublejumpready = true;
		
		}
		Else if(player.onground)
		{
			doublejumpready = false;
			oldjump = false;
			alreadyjumped = false;
		}
		
		if (!invehicle && player.cmd.buttons & BT_JUMP)
		{
			
			/*
			if (player.crouchoffset != 0)
			{
				// Jumping while crouching will force an un-crouch but not jump
				player.crouching = 1;
			}
			else*/ if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
			}
			else if (bNoGravity)
			{
				Vel.Z = 3.;
			}
			else if (player.onground && jumpcooler < 5 || doublejumpready && !oldjump && !alreadyjumped && !(player.readyweapon is "hellishmissilelauncher" && countinv("gas") > 0))
			{
				double jumpvelz = JumpZ * 35 / TICRATE;
				double jumpfac = 0;

				// [BC] If the player has the high jump power, double his jump velocity.
				// (actually, pick the best factors from all active items.)
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;

				Vel.Z = jumpvelz;
				Vel.z += (vel.xy.length() * 0.25);
				//console.printf("%i",vel.z);
				bOnMobj = false;
				player.jumpTics = -1;
				if (!(player.cheats & CF_PREDICTING)) A_StartSound("BDPJUMP", CHAN_BODY);
				If(doublejumpready)
				{
					alreadyjumped = true;
					if (!(player.cheats & CF_PREDICTING)) A_StartSound("JMPBOOT", CHAN_BODY);
				}
				oldjump = true;
			}
			
			jumpcooler++;
		}
		Else if (oldjump)
		{
			oldjump = false;
		}
		else if (jumpcooler)
		{
			jumpcooler = 0;
		}
	}
	
	override void CheckCrouch(bool totallyfrozen)
	{
		let player = self.player;
		UserCmd cmd = player.cmd;

		if (cmd.buttons & BT_JUMP)
		{
			cmd.buttons &= ~BT_CROUCH;
		}
		if (CanCrouch() && player.health > 0)
		{
			if (!totallyfrozen)
			{
				int crouchdir = player.crouching;

				if (crouchdir == 0)
				{
					crouchdir = (cmd.buttons & BT_CROUCH) ? -1 : 1;
				}
				else if (cmd.buttons & BT_CROUCH)
				{
					player.crouching = 0;
				}
				if (crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
				{
					CrouchMove(1);
				}
				else if (crouchdir == -1 && player.crouchfactor > 0.5)
				{
					CrouchMove(-1);
				}
			}
		}
		else
		{
			player.Uncrouch();
		}

		player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		bool allclear;
		
		If(boostlevel >= 3 && other && !other.bmissile && vel.length() >= 15)
		{
			
			other.damagemobj(self,self,24,"extremepunches");
			
			if(other && !other.bnodamagethrust && other.mass <  9999)
			{
				If(other.vel.length() < 8)
				{
					A_startsound("skeleton/melee",28);
				}
				float yeetangle = angleto(other);
				other.velfromangle(35,yeetangle);
				other.vel.z = 6;
				allclear = true;
			}
		}
		
		If(!allclear)
			{
			Return True;
			}
		Else
		{
			Return False;
		}
		
	}
	
	
	bool HookLOS()
	{
		Float LOSPitch = atan2(Rope.XY.Length(), Rope.Z) - 90;
		Float LOSAngle = VectorAngle(Rope.X, Rope.Y);
		FLineTraceData LOSCheck; LineTrace(LOSAngle, Rope.Length(), LOSPitch, TRF_SOLIDACTORS|TRF_BLOCKSELF, Height / 2.f, data: LOSCheck);
		
		if(GrappledMonster != Null && LOSCheck.HitActor == GrappledMonster) { return true; }
		
		return LOSCheck.Distance == Rope.Length();
	}
	
	void GrapplingMove()
	{
		/*if(!brutal_playerbase.OnGround) */{ Grappled = True; }
		
		//Fun is over kids, go home
		if(bNOGRAVITY || Rope.Length() <= 4.f * Radius || !CheckMove(Pos.XY + Vel.XY) || (lasttickrope && rope.length() > (lasttickrope + 30)))
		{
			StopHook();
			return;
		}
		lasttickrope = rope.length();
		
		Usercmd cmd = player.cmd;
			GrappleVel = SafeUnit3(Rope) * GrappleVel.Length();
			Vel = GrappleVel;
			If(cmd.sidemove > 0)
			{
				grapplesidespeed = grapplesidespeed + 2;
			}
			else if(cmd.sidemove < 0)
			{
				grapplesidespeed = grapplesidespeed - 2;
			}
			Acceleration.XY = RotateVector((0, -grapplesidespeed), Angle);
			//
			double currentvel = vel.length();
			vel.xy = (vel.xy + acceleration.xy);
			
			
			//console.printf("%i",rope.length());
			If(!cmd.sidemove && grapplesidespeed > 0)
			{
				grapplesidespeed = grapplesidespeed - 2;
			}
			Else if (!cmd.sidemove && grapplesidespeed < 0)
			{
				grapplesidespeed = grapplesidespeed + 2;
			}
			
	}
	
			
		void StopHook()
	{
		Rope = GrappleVel = (0, 0, 0);
		PendulumLength = 0;
		GrappledMonster = Null;
		grapplesidespeed = 0;
		lasttickrope = 0;
		
	}
		
		//QuakeHandleMove();
		
		//Sprite animation
		//Super.handlemovement();
	
	
	Override void Tick()
    {
	
		if (focusWeapon && !BDPHandler.IsVoodooDoll(self))
		{
			// Check if our and weapon's collision boxes no longer align.
			// If so, flush the focusWeapon pointer:
			if (!BDPHandler.IsAABBColliding(self, focusWeapon))
			{
				focusWeapon = null;
				manualPickup = false;
			}
			// Otherwise if player is pressing Use, let them
			// pick this weapon up:
			else if ((player.cmd.buttons & BT_USE) && !(player.oldbuttons & BT_USE))
			{
				manualPickup = true;
				focusWeapon.Touch(self);
			}
		}
	// Get Distance under crosshair.
			FLineTraceData lt;
			If(player)
			{
				LineTrace(angle, crosshairrange, pitch, 0, player.viewz-pos.z, 0, data:lt);
				
				aimpos = lt.HitLocation;
				aimActor = lt.HitActor;
			}
			
	
	If(findinventory("veh_manager"))
	{
		invehicle = true;
	}
	else
	{
		invehicle = false;
	}
	If(invehicle)
		{
		SetPlayerProperty(0,0,0);
		player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState('InAVehicle'));
		SetStateLabel("invehicle");
		bpickup = false;
		}
		Else
		{
		bpickup = true;
		//if (GetCvar("bd_GenderFemale") == 1) {
		//if (CountInv("GenderFemale") == 1) {
		//	SoundClass = "fplayer";
		//}
		If(CountInv("RollingRight") == 1)
		{
		//player.cheats |= CF_CHASECAM;
		SetStateLabel("rollingright");
		bforcexybillboard = TRUE;
		}
		If(CountInv("RollingLeft") == 1)
		{
		//player.cheats |= CF_CHASECAM;
		SetStateLabel("rollingLeft");
		bforcexybillboard = TRUE;
		}
		If(CountInv("RollFinished") == 1)
		{
		//player.cheats &= ~CF_CHASECAM;
		takeinventory("rollfinished",1);
		bforcexybillboard = FALSE;
		}
		if (CountInv("ExecuteDownedEnemy") == 1)
        {
           TakeInventory("ExecuteDownedEnemy", 10);
		   TakeInventory("GoSpecial", 10);
            player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("DoExecution"));
		//	TakeInventory("ExecuteDownedEnemy", 1);
		//   TakeInventory("GoSpecial", 1);
			SetStateLabel("SpecialChecker");
        }
		
		/*
		if (CountInv("DoStrengthRuneAnim") == 1) {
			TakeInventory("DoStrengthRuneAnim", 1);
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("DoStrengthRuneAnim"));
		}
		*/
		
		If(player && notvoodoo && findinventory("nottitlemap"))
			{
				
		
			let playerArmor = BasicArmor(FindInventory('BasicArmor'));
			If(player && findinventory('ReturnUnmorphStuffPlease'))
				{
				takeinventory('ReturnUnmorphStuffPlease',1);
				
					playerarmor.amount = PreMorpharmor;
					playerArmor.SavePercent = PreMorphArmorPercent;
					a_sethealth(premorphhealth);
				}
	
		
			PreMorphArmor = playerarmor.amount;
			PreMorphArmorPercent =	playerArmor.SavePercent;
			PreMorphHealth = health;
			
			}
			
		}
		super.Tick();
    }
	
	
	//////////////////////////////////////
	// Ledge Grab						//
	//////////////////////////////////////
	
	void LedgeGrabInitiator()
	{
		ZMPlayer = self.player;
		
		//Already ledge grabbing, no clipping, moving away from where you are looking, ceiling already too low for sure
		if((pos.z <= floorz) || LedgeCheck || LedgeGrabbed || (ZMPlayer.Cheats & CF_NOCLIP2) || Vel.XY dot AngleToVector(Angle) <= 0 || CeilingZ <= Pos.Z + Height * 1.6f) { return; }
		
		//============================================
		//Find ledge (if any)						//
		//============================================
		
		FLineTraceData LedgeTrace;
		Float TraceDistance = sqrt(2) * Radius + 1; //account for the fact that Doom's hitboxes are square
		LineTrace(Angle, TraceDistance, 0, TRF_BLOCKSELF|TRF_THRUACTORS, Height * 1.2f, data: LedgeTrace);
		Vector3 HitPos = LedgeTrace.HitLocation;
		
		Int LedgeCandidate;
		if(LedgeTrace.HitType == TRACE_HitWall) //hit wall scenario
		{
			if(LedgeTrace.Hit3DFloor != NULL) //3D floor
			{
				LedgeCandidate = LedgeTrace.Hit3DFloor.Top.ZAtPoint(HitPos.XY);
			}
			else //regular wall
			{
				Line HitLine = LedgeTrace.HitLine;
				if(HitLine.FrontSector != NULL && HitLine.FrontSector != CurSector)
					LedgeCandidate = HitLine.FrontSector.FloorPlane.ZatPoint(HitPos.XY);
				else if(HitLine.BackSector != NULL && HitLine.BackSector != CurSector)
					LedgeCandidate = HitLine.BackSector.FloorPlane.ZatPoint(HitPos.XY);
			}
		}
		else if(LedgeTrace.HitSector != CurSector)//tracer stopper mid air in a sector that is not the one where player currently is
		{
			LedgeCandidate = LedgeTrace.HitSector.NextLowestFloorAt(HitPos.X, HitPos.Y, HitPos.Z, FFCF_3DRESTRICT, 0);
		}
		else
		{
			return;
		}
		
		//Check if the candidate ledge can suffice
		if(LedgeCandidate > Pos.Z + Height * 0.6f && LedgeCandidate <= Pos.Z + Height * 1.2f)
		{
			Vector3 OrigPos = Pos;
			SetXYZ((Pos.XY, LedgeCandidate));
			if(!CheckMove(Pos.XY + 5.f * AngleToVector(Angle))) //not enough space, cancel everything :(
			{
				SetXYZ(OrigPos);
				return;
			}
			SetXYZ(OrigPos);
			LedgeHeight = LedgeCandidate;
			LedgeHeightMin = (LedgeHeight - Height * 0.97f);
			LedgeHeightMax = (LedgeHeight - Height * 0.751f);
		}
		else
		{
			return; //too high/low
		}
		
		/*
		LineTrace(Angle, TraceDistance, 0, TRF_BLOCKSELF|TRF_THRUACTORS|TRF_NOSKY, 0, data: LedgeTrace);
		if (LedgeTrace.HitLine && LedgeTrace.hittype == TRACE_HITWALL) 
		{
			double lineangle = atan2(LedgeTrace.HitLine.delta.y, LedgeTrace.HitLine.delta.x); //angle of the line
			double targangle = lineangle + 90; //this will be the angle of the player
			
			if(targangle < 0) 
			{
				targangle = -(targangle + 90);
			}
			if (LedgeTrace.LineSide)
			{
				targangle *= -1; //reverse it if you're facing the back side of the linedef
			}
			A_SetAngle(targangle,SPF_INTERPOLATE); //set player's angle
		}
		*/
		
		//============================================
		//Abemus ledge, execute						//
		//============================================
		
		//Switch to a weapon that forbids firing during the ledge grab
		
		/*
		//Reset dash stuff just in case
		//MaxAirSpeed = ADashTargetSpeed;
		//DashCooler = ADashCooler = ADashTargetSpeed = WJumpSpeed = DashNumber = 0;
		*/
		
		//Credit Cherno
		//Console.Printf("Num: %f", LedgeHeight);
		
		velz = 8;
		LedgeCheck = True;
		
		if(vel.length() < 5)
		{
			GiveInventory("Grabbing_A_Ledge", 1);
		}
		if(pos.z >= (LedgeHeightMin+20))
		{
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("FinishClimb"));
			
			A_StopSound(CHAN_WEAPON);
			A_StartSound("ledgeclimb");
			LedgeAngle = Angle;
			LedgeCheck = False;
			LedgeGrabbed = True;
			return;
		}
		if((player.readyweapon is "Melee_Attacks") || (player.readyweapon is "Chain_saw") || (player.readyweapon is "BrutalAxe"))
		{
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("StainedLedgeClimb"));
		}
		else
		{
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("LedgeClimb"));
		}
	}
	void LedgeReach()
	{
		LedgeTime++;
		if(LedgeTime >= 30)
		{
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
			LedgeGrabbed = LedgeTime = LedgeHeight = LedgeHeightMin = LedgeHeightMax = FrameTime = 0;
		}
	}
	
	void LedgeGrab()
	{
		if(Pos.Z >= LedgeHeight || !Vel.Length() || LedgeTime >= 35)
		{
			//End Ledge Grab
			LedgeCheck = False;
			SetOrigin((Pos.X, Pos.Y, LedgeHeight), True);
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
			
			//Only if ledge grab was successful
			if(LedgeTime >= 35) { return; }
			LedgeGrabbed = LedgeTime = LedgeHeight = LedgeHeightMin = LedgeHeightMax = FrameTime = 0;
			Vel = Vel.Length() ? (5.f * AngleToVector(LedgeAngle), -3) : (0, 0, 0); //push player forward and downward
			A_StartSound("*land", CHAN_BODY);
		}
		else
		{
			Vel = Vel.Length() ? (0, 0, 8) : (0, 0, 0);
		}
		
		//Fail safe to unlock player movement if something goes wrong
		LedgeTime++;
		if(LedgeTime >= 35)
		{
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
			LedgeGrabbed = LedgeTime = LedgeHeight = LedgeHeightMin = LedgeHeightMax = FrameTime = 0;
		}
		
		//Sprite animation
		PlayIdle();
	}
	
	Override void CalcHeight()
	{
		let player = self.player;
		double angle;
		double bob;
		bool still = false;

		// Regular movement bobbing
		// (needs to be calculated for gun swing even if not on ground)

		// killough 10/98: Make bobbing depend only on player-applied motion.
		//
		// Note: don't reduce bobbing here if on ice: if you reduce bobbing here,
		// it causes bobbing jerkiness when the player moves from ice to non-ice,
		// and vice-versa.

		if (player.cheats & CF_NOCLIP2)
		{
			player.bob = 0;
		}
		else if (bNoGravity && !player.onground)
		{
			player.bob = min(abs(0.5 * FlyBob), MAXBOB);
		}
		else if (rope.length())
		{
			player.bob = 0;
		}
		else
		{
			player.bob = player.Vel dot player.Vel;
			if (player.bob == 0)
			{
				still = true;
			}
			else
			{
				player.bob *= player.GetMoveBob();

				if (player.bob > MAXBOB)
					player.bob = MAXBOB;
			}
		}

		double defaultviewheight = ViewHeight + player.crouchviewdelta;

		if (player.cheats & CF_NOVELOCITY)
		{
			player.viewz = pos.Z + defaultviewheight;

			if (player.viewz > ceilingz-4)
				player.viewz = ceilingz-4;

			return;
		}

		if (bFly && !GetCVar("FViewBob"))
		{
			bob = 0;
		}
		else if (still)
		{
			if (player.health > 0)
			{
				angle = Level.maptime / (120 * TICRATE / 35.) * 360.;
				bob = player.GetStillBob() * sin(angle);
			}
			else
			{
				bob = 0;
			}
		}
		else
		{
			angle = Level.maptime / (ViewBobSpeed * TICRATE / 35.) * 360.;
			bob = player.bob * sin(angle) * (waterlevel > 1 ? 0.25f : 0.5f);
		}

		// move viewheight
		if (player.playerstate == PST_LIVE)
		{
			player.viewheight += player.deltaviewheight;

			if (player.viewheight > defaultviewheight)
			{
				player.viewheight = defaultviewheight;
				player.deltaviewheight = 0;
			}
			else if (player.viewheight < (defaultviewheight/2))
			{
				player.viewheight = defaultviewheight/2;
				if (player.deltaviewheight <= 0)
					player.deltaviewheight = 1 / 65536.;
			}
			
			if (player.deltaviewheight)	
			{
				player.deltaviewheight += 0.25;
				if (!player.deltaviewheight)
					player.deltaviewheight = 1/65536.;
			}
		}

		if (Alternative)
		{
			bob = 0;
		}
		player.viewz = pos.Z + player.viewheight + (bob * clamp(ViewBob, 0. , 1.5)); // [SP] Allow DECORATE changes to view bobbing speed.

		if (Floorclip && player.playerstate != PST_DEAD
			&& pos.Z <= floorz)
		{
			player.viewz -= Floorclip;
		}
		if (player.viewz > ceilingz - 4)
		{
			player.viewz = ceilingz - 4;
		}
		if (player.viewz < floorz + 4)
		{
			player.viewz = floorz + 4;
		}
	}
}


Class Hook : Actor
{
	Default
	{
		+FORCEXYBILLBOARD;
		+HITMASTER;
		+MISSILE;
		+NOGRAVITY;
		+NOTELEPORT;
		//+alwayspuff;
		+puffonactors;
		+NOTONAUTOMAP;
		+THRUSPECIES;
		//+seekermissile;
		//+screenseeker;
		//+doombounce;
		//+bounceonfloors;
		//+bounceonwalls;
		+dontcorpse;
		+explodeonwater;
		//+noclip;
		Damagefunction 0;
		+nodamagethrust;
		Height 4;
		Radius 10;
		Speed 1;
		Species "Hook";
		+puffgetsowner;
	//	+forcepain; 
		//bouncefactor 0.1;
		+NOTIMEFREEZE;
	}
	
	vector3 HookToPlayer;
	vector3	HookToMonster;
	int		MonsterSpeed;
	int		MonsterFloatSpeed;
	float maxdistnew;
	//bool bisflaming;
	
	vector3 SafeUnit3(Vector3 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	vector2 SafeUnit2(Vector2 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	Override void Tick()
	{
		//bool isflaming = false;
		Let HookOwner = brutal_playerbase(Target);
		if(HookOwner)
		{
			Vector3 WaistPos = (HookOwner.Pos.X, HookOwner.Pos.Y, HookOwner.Pos.Z + HookOwner.Height / 2.f); // player position
			HookToPlayer = Pos - WaistPos; //hook-to-player vector
			
		}
		
		Super.Tick();
		
		UpdateTrail();
	}
	
	void UpdateTrail()
	{
		int b;
		for(b = 1; b <= 14; b++)
		{
			ActorIterator BallOfSteele = Level.CreateActorIterator(84115 + b);
			Actor Ball = BallOfSteele.Next();
			
			if(Ball != Null)
			{
				//Set trail velocity
				Vector3 TargetPos = Pos - (HookToPlayer * b / 15.f);
				Ball.Vel = TargetPos - Ball.Pos;
			}
		}
	}
	
	void InitiateGrapple(Bool Monster)
	{
		Let HookOwner = brutal_playerbase(Target);
		
		Float	PushLength = 4 * 5.5;
		Vector3 HookPush = SafeUnit3(HookToPlayer) * PushLength;
		Float 	HookSpeed = max((HookPush).Length(), PushLength);
		HookOwner.Rope = HookToPlayer; //needed for the LOS check
		
		//Check hook is still in sight
		//if(!HookOwner.HookLOS())
		//{
		//	SetState(FindState("DespawnHook"));
		//	return;
		//}
		
		//Stop any eventual wall slides
		/*
		HookOwner.StopWSlide();
		
		//Stop dashing stuff
		HookOwner.ADashCooler = HookOwner.ADashTargetSpeed = 0;
		
		//Initiate hook
		*/
		HookSpeed = HookOwner.MaxAirSpeed = min(HookSpeed, 24);
		HookOwner.Vel = HookOwner.GrappleVel = HookSpeed * SafeUnit3(HookPush);
		
		//Hooking monsters specific
		if(Monster)
		{
			Let Monster = Actor(Master);
			If(!monster.bnoblood)
			{
			Monster.spawnblood(pos,angle,1);
			}
			monster.a_pain();
			brutal_playerbase(Target).GrappledMonster = Monster;
			SetMonsterSpeed(False);
			A_StartSound("HookMeat", 7);
		}
		else
		{
			A_StartSound("HookWall", 7);
		}
	}
	
	void SetMonsterSpeed(Bool Reset)
	{
		Let Monster = Actor(Master);
		/*
		if(!Reset)
		{
			MonsterSpeed = Monster.Speed;
			MonsterFloatSpeed = Monster.FloatSpeed;
			Monster.Speed = Monster.FloatSpeed = 0;
		}
		else
		{
			Monster.Speed = MonsterSpeed;
			Monster.FloatSpeed = MonsterFloatSpeed;
		}
		*/
	}
	
	void SpawnTrail()
	{
		int h;
		for(h = 1; h <= 14; h++)
		{
			
			A_SpawnItemEx("HookTrail",0,0,0,0,0,0,0,SXF_ISTRACER|SXF_SETTARGET|SXF_ORIGINATOR|SXF_NOCHECKPOSITION);
			
			
			Let SlaveTrail = HookTrail(Tracer);
			SlaveTrail.ChangeTid(84115 + h);
		}
	}
	
	
	

	
	States
	{
	//====================================
	//Hook is traveling through space
	Spawn:
		OCLW A 0 NoDelay
		{
			Let HookOwner = brutal_playerbase(Target);
			A_AlertMonsters();
			
			 if (target && target.target)
			 {//ensure that the shooter even has a target
            SetOrigin(target.target.pos+(0,0,target.target.height*0.5),false);
			target.a_cleartarget();
			}
			SpawnTrail();
			//HookOwner.a_takeinventory("meathook",1);
			
		}
	Looper:
		OCLW A 1
		{
			//a_seekermissile(365,365,SMF_LOOK);
			Let HookOwner = brutal_playerbase(Target);
			//target.giveinventory("meathook",1);
			//Despawn if no geometry was found
			/*
			if(HookToPlayer.Length() >= 1300.f || !HookOwner)
			{
				SetState(FindState("Death"));
				return;
			}
			*/
		}
		Goto despawnhook;
	
	//====================================
	//Hook hit a wall or ceiling

	
	
	TillDeathDoesUsApart:
		OCLW A 1
		{
			Let HookOwner = brutal_playerbase(Target);
			if(!HookOwner.GrappleVel.Length() || !HookOwner)
			{
				SetState(FindState("DespawnHook"));
				return;
			}
			
			if(HookOwner)
		{
			Vector3 WaistPos = (HookOwner.Pos.X, HookOwner.Pos.Y, HookOwner.Pos.Z + HookOwner.Height / 2.f); // player position
			HookToPlayer = Pos - WaistPos; //hook-to-player vector
			
			
		}
		
		
		UpdateTrail();
			
			HookOwner.Rope = HookToPlayer;
		}
		Loop;
		
	//====================================
	//Hit actor
	XDeath:
	//Melee:
		OCLW A 1
		{

			
			Let HookOwner = brutal_playerbase(Target);
			//SpawnTrail();
			Let Monster = Actor(Master);
			
		
			
			InitiateGrapple(True); 
			maxdistnew = HookToPlayer.length();
		}
	
	TillXDeathDoesUsApart:
		OCLW A 1
		{
			Let HookOwner = brutal_playerbase(Target);
			Let Monster = Actor(Master);
			If (monster)
			{
			setorigin(monster.pos+(0,0,monster.height*0.5),TRUE);
			}
			
			if(!HookOwner || !HookOwner.GrappleVel.Length() || !Monster || Monster.health <=0)
			{
				return resolvestate("despawnhook");
			}
			
			
				if(HookOwner)
		{
			Vector3 WaistPos = (HookOwner.Pos.X, HookOwner.Pos.Y, HookOwner.Pos.Z + HookOwner.Height / 2.f); // player position
			HookToPlayer = Pos - WaistPos; //hook-to-player vector
			
			
			
			
		}
		
		
		UpdateTrail();
			
			
			a_startsound("MHKLOOP",194,CHANF_LOOPING,0.5,ATTN_NONE);
			/*
			if (monster.FindState('Pain.meathook') && !monster.bdormant && !monster.bnopain && !monster.findinventory("glorykillme") && !monster.findinventory("enemyisarchvile"))
			{
			Monster.setstatelabel("pain.meathook");
			}
			Else if (monster.FindState('Pain') && !monster.bdormant && !monster.bnopain && !monster.findinventory("glorykillme") && !monster.findinventory("enemyisarchvile"))
			{
			Monster.setstatelabel("pain");
			}
			*/
			
			
			Vel = Monster.Vel;
			HookOwner.Rope = HookToPlayer;
			Return resolvestate(null);
		}
		Loop;
		
	//====================================
	//Die Monster! You don't belong in this world
	Death:
	OCLW AAA 0
		{
			Let HookOwner = brutal_playerbase(Target);
			if(HookOwner)
			{
			//	HookOwner.a_giveinventory("canfiremeathook",1);
				HookOwner.StopHook();
			//	HookOwner.a_giveinventory("meathook",1);
				//HookOwner.a_startsound("weapons/empty",194,CHANF_DEFAULT,1,ATTN_NONE);
			}
			a_stopsound(194);
			Let Monster = Actor(Master);
			if(Monster && MonsterSpeed) { SetMonsterSpeed(True); }
		}
		Stop;
		
	DespawnHook:
		OCLW A 0
		{
			Let HookOwner = brutal_playerbase(Target);
			if(HookOwner)
			{
				HookOwner.StopHook();
			//	HookOwner.a_giveinventory("canfiremeathook",1);
			//	HookOwner.a_giveinventory("meathook",1);
				HookOwner.a_startsound("MHKSTP",194,CHANF_DEFAULT,1,ATTN_NONE);
			}
			a_stopsound(194);
			Let Monster = Actor(Master);
			if(Monster && MonsterSpeed) { SetMonsterSpeed(True); }
		}
		Stop;
	}
}

Class HookTrail : Actor
{
	Default
	{
		+FORCEXYBILLBOARD;
		+MISSILE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NOTONAUTOMAP;
		+THRUSPECIES;
		+ExplodeOnWater;
		Radius 2;
		Height 4;
		Scale 0.5;
		Species "HookTrail";
		+NOTIMEFREEZE;
	}
	
	States
	{
		Spawn:
		Looper:
			TEND A 1
			{
				if(!Hook(Target))
				{
					SetState(FindState("DespawnTrail"));
					return;
				}
				
			
			}
			Loop;
			
		Death:
			TEND A 1
			{
				if(!Hook(Target))
				{
					SetState(FindState("DespawnTrail"));
					return;
				}
			}
			Loop;
			
		DespawnTrail:
			Stop;
	}
}

Class Speedline : Actor
{
	Default
	{
		+nogravity;
		Renderstyle "Add";
		Alpha 0.2;
		+noteleport;
		+noclip;
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NODELAY A_recoil(30);
			TRAC A 5;
			Spawn2:
			TRAC A 1 A_FadeOut(0.10);
			LOOP;
	
	}

}

//DarkDoomZ flashlight!

class BDP_Flashlight : CustomInventory {
	BDP_Spotlight SelfLight1, SelfLight2;
	bool Active;
	int Quality,OldQuality;
	int Type,OldType;
	int Mount,OldMount;
	int R,G,B;
	int beamInner, beamOuter, beamRadius;
	int spillInner, spillOuter, spillRadius;
	double offsetAngle, offsetZ;
	int inertia;
	double spring, damping;

	default {
		+INVENTORY.PERSISTENTPOWER;
		+inventory.autoactivate;
	}
	Override void detachfromowner()
	{
	
	if(SelfLight1) { SelfLight1.Destroy(); }
	if(SelfLight2) { SelfLight2.Destroy(); }
	Super.detachfromowner();
	}

	override void DoEffect() {
		super.DoEffect();
		
				
				if(SelfLight1) { SelfLight1.Destroy(); }
				if(SelfLight2) { SelfLight2.Destroy(); }
			

			
				//	R = 255;
				//	G = 214;
				//	B = 170;
				//	beamInner = 0;
				//	beamOuter = 25;
				//	beamRadius = 384;
					//spillInner = 15;
				//	spillOuter = 45;
				//	spillRadius = 128;
				//	break;
				//case 1: //Halogen
					R = 255;
					G = 237;
					B = 162;
					beamInner = 0;
					beamOuter = 20;
					beamRadius = 512;
					
					
					spillInner = 10;
					spillOuter = 60;
					spillRadius = 384;
					
					If (owner.findinventory("powernightvisneo"))
					{
						Beamradius = 1500;
						SpillRadius = 1200;
					}
					//break;
				/*case 2: //LED
					R = 248;
					G = 255;
					B = 255;
					beamInner = 0;
					beamOuter = 15;
					beamRadius = 640;
					spillInner = 15;
					spillOuter = 75;
					spillRadius = 256;
					break;
				case 3: //Red filter
					R = 192;
					G = 36;
					B = 34;
					beamInner = 0;
					beamOuter = 20;
					beamRadius = 256;
					spillInner = 10;
					spillOuter = 60;
					spillRadius = 128;
					break;
					*/
			

			/*
				case 0: //Handheld
					spring = 0.25;
					damping = 0.2;
					inertia = 4;
					offsetAngle = 0;
					offsetZ = -13;
					break;
				case 1: //Left Shoulder
					spring = 0.35;
					damping = 0.75;
					inertia = 2;
					offsetAngle = 80;
					offsetZ = -5;
					break;
				case 2: //Right Shoulder
					spring = 0.35;
					damping = 0.75;
					inertia = 2;
					offsetAngle = -80;
					offsetZ = -5;
					break;
				case 3: //Helmet
				*/
					spring = 1;
					damping = 1;
					inertia = 1;
					offsetAngle = 0;
					offsetZ = 4;
					//break;
			

			
					if(!SelfLight1) {
						SelfLight1 = BDP_Spotlight(Spawn("BDP_Spotlight",owner.pos,false));
						SelfLight1.FollowTarget = owner;
						SelfLight1.args[DynamicLight.LIGHT_RED] = R; //R
						SelfLight1.args[DynamicLight.LIGHT_GREEN] = G; //G
						SelfLight1.args[DynamicLight.LIGHT_BLUE] = B; //B
						SelfLight1.args[DynamicLight.LIGHT_INTENSITY] = (beamRadius + spillRadius) / 2; //Radius
						SelfLight1.SpotInnerAngle = (beamInner + spillInner) / 2;
						SelfLight1.SpotOuterAngle = (beamOuter + spillOuter) / 2;
						SelfLight1.angle = owner.angle;
						SelfLight1.pitch = owner.pitch;
						SelfLight1.spring = spring;
						SelfLight1.damping = damping;
						SelfLight1.inertia = inertia;
						SelfLight1.offsetAngle = offsetAngle;
						SelfLight1.offsetZ = offsetZ;
					
			
					if(!SelfLight1) {
						SelfLight1 = BDP_Spotlight(Spawn("BDP_Spotlight",owner.pos,false));
						SelfLight1.FollowTarget = owner;
						SelfLight1.args[DynamicLight.LIGHT_RED] = R; //R
						SelfLight1.args[DynamicLight.LIGHT_GREEN] = G; //G
						SelfLight1.args[DynamicLight.LIGHT_BLUE] = B; //B
						SelfLight1.args[DynamicLight.LIGHT_INTENSITY] = beamRadius; //Radius
						SelfLight1.SpotInnerAngle = beamInner;
						SelfLight1.SpotOuterAngle = beamOuter;
						SelfLight1.angle = owner.angle;
						SelfLight1.pitch = owner.pitch;
						SelfLight1.spring = spring;
						SelfLight1.damping = damping;
						SelfLight1.inertia = inertia;
						SelfLight1.offsetAngle = offsetAngle;
						SelfLight1.offsetZ = offsetZ;
					
				
						SelfLight2 = BDP_Spotlight(Spawn("BDP_Spotlight",owner.pos,false));
						SelfLight2.FollowTarget = owner;
						SelfLight2.args[DynamicLight.LIGHT_RED] = int(R * 0.75); //R
						SelfLight2.args[DynamicLight.LIGHT_GREEN] = int(G * 0.75); //G
						SelfLight2.args[DynamicLight.LIGHT_BLUE] = int(B * 0.75); //B
						SelfLight2.args[DynamicLight.LIGHT_INTENSITY] = spillRadius; //Radius
						SelfLight2.SpotInnerAngle = spillInner;
						SelfLight2.SpotOuterAngle = spillOuter;
						SelfLight2.angle = owner.angle;
						SelfLight2.pitch = owner.pitch;
						SelfLight2.spring = spring;
						SelfLight2.damping = damping;
						SelfLight2.inertia = inertia;
						SelfLight2.offsetAngle = offsetAngle;
						SelfLight2.offsetZ = offsetZ;
					
			}
		}
		else {
			if(SelfLight1) { SelfLight1.Destroy(); }
			if(SelfLight2) { SelfLight2.Destroy(); }
		}
		if (level.time % 5 == 0 && !owner.findinventory("powernightvisneo"))
		{
			FLineTraceData AlertTrace;
			owner.LineTrace(Owner.Angle, 328, owner.pitch, TRF_SOLIDACTORS, owner.height * 0.5, data: AlertTrace);
		
			let alerter = Spawn("flashlightalert",alerttrace.hitlocation);
			If(alerter)
			{
				Alerter.target = owner;
				Alerter.a_alertmonsters(150);
			}
		}
		
	}

	States {
	Spawn:
		ROCK A -1;
		stop;
Use:
		TNT1 A 1;
		loop;
	}


}


class BDP_Spotlight : DynamicLight {
	actor FollowTarget;
	double vela, velp;
	double spring, damping;
	double offsetAngle, offsetZ;
	vector3 targetPos;
	int inertia;

	default {
		DynamicLight.Type "Point";
		+DYNAMICLIGHT.ATTENUATE;
		+DYNAMICLIGHT.SPOT
	}
	override void Tick() {
		super.Tick();
		if(followTarget && followTarget.player) {
			if(inertia == 0) inertia = 1;
			targetpos = followTarget.vec3Angle(
				2 + (6 * abs(sin(offsetAngle))),
				followtarget.angle + offsetAngle,
				followtarget.player.viewheight + offsetZ,
				false);
			vel.x += DampedSpring(pos.x, targetpos.x, vel.x, 1, 1);
			vel.y += DampedSpring(pos.y, targetpos.y, vel.y, 1, 1);
			vel.z += DampedSpring(pos.z, targetpos.z, vel.z, 1, 1);
			vela  += DampedSpring(angle, followTarget.angle, vela, spring, damping);
			velp  += DampedSpring(pitch, followTarget.pitch, velp, spring, damping);
			setOrigin(pos + vel, true);
			A_SetAngle(angle + (vela / inertia), true);
			A_SetPitch(pitch + (velp / inertia), true);
		}
	}

	double DampedSpring(double p, double r, double v, double k, double d) {
		return -(d * v) - (k * (p - r));
	}
}


Class FlashlightAlert : Actor
{
	Default
	{
		projectile;
	}
	
	States
	{
		Spawn:
			TNT1 A 1;
			STOP;
	
	}
}

Class ScannerEffect : Actor
{
	Int scalevalue;
		Default
			{
				+nogravity;
				renderradius 2000;
				Alpha 0.2;
			}
			States
			{
				Spawn:
					NUKF A 1 BRIGHT
					{
					scalevalue = (scalevalue + 45);
					A_setscale(scalevalue,scalevalue);
					A_fadeout(0.002);
					}
					LOOP;
			}
}

class VisorLight: DynamicLight {

	default {
		DynamicLight.Type "Point";
		+DYNAMICLIGHT.ATTENUATE;
		+DYNAMICLIGHT.SPOT
	}
	override void tick(){
		If(target)
		{
			SpotInnerAngle = 90;
			SpotOuterAngle = 90;
			setorigin((target.pos.xy,target.pos.z+target.height),true);
			//console.printf("I'M ALIVE");
			pitch = target.pitch;
			angle = target.angle;
			
		}
	}
}
