
class Brutal_PlayerBase : PlayerPawn
{
	//=========================
	//Common
	
	const BOB_MIN_REALIGN 	 = 0.25f;
	const GROUND_DASH_COOLER = 18;
	
	//Movement General
	bool	Pain;
	double	ViewAngleDelta;
	float	ActualSpeed;
	float	MaxAirSpeed;
	float 	MaxGroundSpeed;
	float	MoveFactor;
	int		AnimateJump;
	int		ForceVelocity;
	int		MoveType;
	int		OldFloorZ;
	playerinfo ZMPlayer;
	vector2 OldVelXY;
	vector3	Acceleration;
	
	//////////////////
	
	//Jumping
	bool 	BlockJump;
	bool	Jumped;
	bool	doublejumpready;
	bool	alreadyjumped;
	bool	oldjump;
	float	FloorAngle;
	int		DoubleJumpCooler;
	int		JumpSoundCooler;
	
	//Double Jump
	bool	BlockDoubleJump;
	bool	CanDoubleJump;
	
	//Elevator Jumps
	float	ElevatorJumpBoost;
	int		OldSecIndex;
	
	//////////////////
	
	//Double Tap
	int		FirstTapTime;
	int		FirstTapValue;
	int		OldTapValue;
	
	//Dashing
	float	WJumpSpeed;
	int		DashNumber;
	int		DashCooler;
	
	//Air Dashing
	float	ADashTargetSpeed;
	int		ADashCooler;
	int		ADashFrictionDelay;
	
	//WallJump
	int		CheckForWJump;
	
	//WallSlideMove
	bool	CanWSlide;
	int		CheckForWSlide;
	vector2	WSlideVelocity;
	
	//Crouch Slide
	bool	CanCSlide;
	float	MaximumSlideSpeed;
	float	QSlideDuration;
	int		CSlideStartTime;
	
	//Ledge Grabbing
	bool	LedgeGrabbed;
	float	LedgeAngle;
	int		LedgeHeight;
	bool	LedgeCheck;
	int		LedgeTime;
	int		LedgeHeightMax;
	int		LedgeHeightMin;
	float	FrameTime;
	double	velx;
	double	vely;
	double	velz;
	weapon	ReselectWeapon;
	
	//Grappling Hook
	actor	GrappledMonster;
	actor	HookFired;
	bool	Grappled;
	float	PendulumLength;
	vector3	GrappleVel;
	vector3 Rope;
	int grapplesidespeed;
	double lasttickrope;
	
	//Booster Frame
	int boosttics;
	int boostlevel;
	double lasttickvellength;
	bool booster;
	
	//////////////////
	
	//View Bobbing
	bool	PostLandingBob;
	float	ZMBob;
	
	//Weapon bobbing
	bool	DoBob;
	double	BobTime;
	double	HorizontalSway;
	double	BobRange;
	double 	OldTicFrac;
	double	VerticalOffset;
	
	//=========================
	//Painkiller only
	
	//Movement
	bool	TrickFailed;
	float	AirControl;
	float	ActualMaxAirSpeed;
	
	//Jumping
	float	TrickJumpAngle;
	int		SmallerJumpHeight;
	
	//=========================
	//Build Engine Only
	
	//Movement
	bool	DeepWater;
	float	LandingVelZ;
	int		FVel;
	int		SVel;
	int		UVel;
	
	int		DualTimer;
	Int		SpecialTimer;
	Int		GrenadeTimer;
	
	//Jumping
	int		BuildJumpDelay;
	
	
	//Saved morph stuff
	int PreMorphArmor;
	float PreMorphArmorPercent;
	int PreMorphHealth;
	
	bool notvoodoo;
	bool previouschasecam;
	
	//Soul granting
	
	int previouskills;
	int currentkills;
	
	//Merciless Extermination
	
	bool mercilessgranted;
	
	//Skulls
	bool spawnwitharmor;
	bool spawnberserked;
	bool shockfactor;
	bool istactical;
	bool oneupmanship;
	bool ultranightmare;
	int ultraseed;
	bool alreadyblacklisted;
	bool extralifegranted;
	
	Default
    {
		Player.DisplayName "ZMovement Player";
        PainChance 255;
    }
	
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////																						////
	//// Non-Movement Stuff																		////
	////																						////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	
	//Because GZDoom's Unit() returns NaN if a vector has no value
	vector3 SafeUnit3(Vector3 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	vector2 SafeUnit2(Vector2 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	Override int takespecialdamage(Actor inflictor, Actor source, int damage, Name damagetype)
		{
			If(inflictor is "grenadeexplosion" && source == self)
			{
				Damage = (damage * 0.25);
			}
			If(source is "BDPBIKE" && !findinventory("veh_manager"))
				{
					damage = 0;
					SetStateLabel("pain.bikelaunch");
					
				}
			If(grappled)
				{
					Damage = (damage * 0.25);
				}
				
			return super.TakeSpecialDamage(inflictor, source, damage, damagetype);
				
		
		
		}
	
	Override void playerthink()
		{
		Super.playerthink();
		
		
		currentkills = Level.Killed_monsters;
		If(currentkills > previouskills)
		{
			giveinventory("soulammo",(currentkills - previouskills));
			//console.printf("Soul Extracted");
		}
		previouskills = Level.Killed_monsters;
		
		If(currentkills == 0)
		{
			mercilessgranted = false;
		}
		If(!mercilessgranted && currentkills > 5 && currentkills >= Level.Total_Monsters)
		{
			mercilessgranted = true;
			A_Print("MERCILESS EXTERMINATION!",5);
			If(health < 100)
			{
				A_sethealth(100);
			}
			A_startsound("ALLKILL",227,CHANF_LOCAL,1.0,ATTN_NONE);
			If(random(0,50) == 5)
			{
				A_startsound("YIPPEE",228,CHANF_LOCAL,1.0,ATTN_NONE);
			}
			
		}
		
		If(ultranightmare && !ultraseed)
		{
		
			string data = bdp_seed_blacklist;
			Array<string> blacklist;
			data.Split(blacklist,",");
			
			int ultraseedcandidate = random(1,99999999999);
			bool candidatetaken;
			for(int i=0; i<blacklist.Size(); i++)
			{	
				int blacklistint = (blacklist[i].ToInt(10));
				//console.printf("%i",blacklistint);
				If(blacklistint == ultraseedcandidate)
				{
					candidatetaken = true;
				}
			
			}
			If(!candidatetaken)
			{
				ultraseed = ultraseedcandidate;
				//console.printf("%i",ultraseed);
			}
				
			
		}
		
		if(ultraseed)
		{
			
			If((health < 1) && !alreadyblacklisted)
			{
				A_Print("\cgThe nightmare has ended.",999);
				ACS_NamedExecuteAlways("BDNightmareDeath", 0, 0, 0, 0);
				string ultraseedstring = (string.format("%i", ultraseed));
				//Console.printf(ultraseedstring);
				let sv_blacklist = CVar.GetCVar("bdp_seed_blacklist", players[consoleplayer]);

				if(bdp_seed_blacklist == "") 
				sv_blacklist.SetString(ultraseedstring);
				else
				sv_blacklist.SetString(String.Format("%s, %s", bdp_seed_blacklist, ultraseedstring));
				//console.printf("%s, %s", bdp_seed_blacklist, ultraseedstring);
				Alreadyblacklisted = true;
			}
			
			
			If((health >= 1))
			{
				string data = bdp_seed_blacklist;
				Array<string> blacklist;
				data.Split(blacklist,",");
				for(int i=0; i<blacklist.Size(); i++)
				{	
					int blacklistint = (blacklist[i].ToInt(10));
					//console.printf("%i",blacklistint);
					If(blacklistint == ultraseed)
					{
						//candidatetaken = true;
						damagemobj(null,null,9999999,"explosiveimpact");
						A_Print("\cgThe nightmare has ended.",999);
						ACS_NamedExecuteAlways("BDNightmareLoad", 0, 0, 0, 0);
						//S_ChangeMusic("ORB");
						Alreadyblacklisted = true;
						//console.printf("FAGGOT");
					}
			
				}
			}
			
		}	
		
		if(ultranightmare && oneupmanship && !extralifegranted)
		{
			A_giveinventory("extralife",3);
			Extralifegranted = true;
		}
		
		If(spawnwitharmor && !findinventory("powershield",TRUE) && health > 0)
		{
			GiveInventory("PowerShield2",1);
			If(countinv("basicarmor") < 50)
			{
				takeinventory("basicarmor",50);
				GiveInventory("mjolnirarmor",50);
			}
		}
		
		If(spawnberserked && !findinventory("powerstrength",TRUE) && health > 0)
		{
			GiveInventory("Berserk2",1);
			If((health) < 50)
			{
				a_sethealth(100);
			}
		}
		
		
		
		
		If(shockfactor && level.time % 5 == 0)
		{
			A_alertmonsters(0,AMF_TARGETEMITTER);
		}
		
		If(countinv("extralife") > 0)
		{
			bbuddha = true;
			If((health) <= 1)
			{
				a_sethealth(100);
				A_takeinventory("extralife",1);
				A_giveinventory("miniinvul",1);
				A_startsound("items/soulsphere",212);
			}
		}
		Else
		{
			bbuddha = false;
		}
		
		//giveinventory("meathook",1);
		If (istactical)
		{
		Giveinventory("istacticalclass",1);
		Takeinventory("isnottacticalclass",1);
		}
		Else
		{
		Giveinventory("isnottacticalclass",1);
		Takeinventory("istacticalclass",1);
		}
		If(dualtimer >= 1)
		{
		Dualtimer = dualtimer - 1;
		}
		
		If(specialtimer >= 1)
		{
		Specialtimer = specialtimer - 1;
		}
		
		If(Grenadetimer >= 1)
		{
		Grenadetimer = Grenadetimer - 1;
		}
		
		If(health < 1)
		{
		A_stopsound(125);
		A_stopsound(126);
		}
		
		If(player.cmd.buttons & BT_USER3 && dualtimer <= 0)
			{
			dualtimer = 17;
			giveinventory("startdualwield",1);
			}
		If(player.cmd.buttons & BT_USER4 && specialtimer <= 0)
			{
			specialtimer = 17;
			giveinventory("swapriflespecial",1);
			}
		If(player.cmd.buttons & BT_USER2 && grenadetimer <= 0)
			{
			grenadetimer = 8;
			giveinventory("TossGrenade",1);
			}
		If(player.cmd.buttons & BT_ATTACK)
			{
			giveinventory("firedprimary",1);
			}
	
		
		}
	
	
	Override void HandleMovement() { 
	
		
		notvoodoo = true;
		
		if(GetCvar("donotclimb") == 0) 
		{
			If(LedgeCheck)
			{
				if(countinv("usedstamina") < 60)
				{	
					LedgeReach();
				
				
				}
				Else
				{
					A_startSound("Tired", 21,CHANF_NOSTOP);
				}
			}
			if(LedgeGrabbed)
			{
				LedgeGrab();
			}
			LedgeGrabInitiator();
		}
		if(GetCVAR("donotdoublejump") == 0) 
		{
			//CheckJump();
		}
		if(GrappleVel.Length())
			{
				takeinventory("meathook",1);
				GrapplingMove();
			}
		Else
			{
				giveinventory("meathook",1);
				Grappled = False; 
			}
			
		super.HandleMovement();
		
	}
	
	override void moveplayer()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
		If(countinv("powerboost") > 0)
		{
			Booster = true;
		}
		Else
		{
			Booster = false;
		}

		
		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks)
		{
			player.turnticks--;
			Angle += (180. / TURN180_TICKS);
		}
		else
		{
			Angle += cmd.yaw * (360./65536.);
		}

		player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);

		// killough 10/98:
		//
		// We must apply thrust to the player and bobbing separately, to avoid
		// anomalies. The thrust applied to bobbing is always the same strength on
		// ice, because the player still "works just as hard" to move, while the
		// thrust applied to the movement varies with 'movefactor'.
		
		If(player.onground)
		{
			takeinventory("jetpackmoving",1);
		}
		
		Bool jetpacking = countinv("jetpackmoving");
		
		If(booster && cmd.forwardmove && cmd.buttons & BT_SPEED)
		{
			boosttics++;
			If(boosttics >= 35)
			{
				boostlevel++;
				boosttics = 0;
			}
		}
		Else if (boostlevel > 0)
		{
			boosttics++;
			If(boosttics >= 5)
			{
				boostlevel--;
				boosttics = 0;
			}
		}
		Else
		{
			boosttics = 0;
		}
		console.printf("%i",vel.length());
		
		
		if (cmd.forwardmove | cmd.sidemove)
		{
			double forwardmove, sidemove;
			double bobfactor;
			double friction, movefactor;
			double fm, sm;

			[friction, movefactor] = GetFriction();
			bobfactor = friction < ORIG_FRICTION ? movefactor : ORIG_FRICTION_FACTOR;
			if (!player.onground && !bNoGravity && !waterlevel && !jetpacking && !rope.length())
			{
				// [RH] allow very limited movement if not on ground.
				movefactor *= level.aircontrol;
				bobfactor*= level.aircontrol;
			}

			fm = cmd.forwardmove;
			sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds (fm, sm);
			fm *= Speed / 256;
			sm *= Speed / 256;

			// When crouching, speed and bobbing have to be reduced
			if (CanCrouch() && player.crouchfactor != 1)
			{
				fm *= player.crouchfactor;
				sm *= player.crouchfactor;
				bobfactor *= player.crouchfactor;
			}
			
			If(boostlevel >= 1)
			{
				fm = fm + (boostlevel * 10);
			}

			forwardmove = fm * movefactor * (35 / TICRATE);
			sidemove = sm * movefactor * (35 / TICRATE);

			if (forwardmove)
			{
				Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
				ForwardThrust(forwardmove, Angle);
			}
			if (sidemove)
			{
				let a = Angle - 90;
				Bob(a, cmd.sidemove * bobfactor / 256., false);
				Thrust(sidemove, a);
			}

			if (!(player.cheats & CF_PREDICTING) && (forwardmove != 0 || sidemove != 0))
			{
				PlayRunning ();
			}

			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
			
			If(jetpacking)
			{
				vel.xy *= 0.97;
			}
			
		}
		If(boostlevel > 1 && vel.length() < (lasttickvellength * 0.5))
		{
			A_stop();
			A_recoil(14);
			vel.z = 10;
			A_Quake(boostlevel,12,0,800);
			boostlevel = 0;
			boosttics = 0;
			A_startsound("melee/backsmack",28);
			
			
		}
		
		lasttickvellength = vel.length();
		
		If(boostlevel > 1)
		{
			
			a_spawnitemex("Speedline",140,frandom(40,-40),frandom(0,80),vel.length() - 30,vel.z,0);
			a_spawnitemex("Speedline",140,frandom(40,-40),frandom(0,80),vel.length() - 30,vel.z,0);
			a_spawnitemex("Speedline",140,frandom(40,-40),frandom(0,80),vel.length() - 30,vel.z,0);
			
			Actor speedMo = Spawn("PlayerSpeedTrail", Pos, NO_REPLACE);
			if (speedMo)
			{
				speedMo.Angle = Angle;
				speedMo.Translation = Translation;
				speedMo.target = Self;
				speedMo.sprite = sprite;
				speedMo.frame = frame;
				speedMo.Floorclip = Floorclip;

				// [BC] Also get the scale from the owner.
				speedMo.Scale = Scale;

				if (Self == players[consoleplayer].camera &&
					!(player.cheats & CF_CHASECAM))
				{
					speedMo.bInvisible = true;
				}
			}
		}
	
	}
	override void CheckJump()
	{
		
		let player = self.player;
		// [RH] check for jump
		If(!player.onground && !doublejumpready && !oldjump)
		{
			doublejumpready = true;
		
		}
		Else if(player.onground)
		{
			doublejumpready = false;
			oldjump = false;
			alreadyjumped = false;
		}
		
		if (player.cmd.buttons & BT_JUMP)
		{
			if (player.crouchoffset != 0)
			{
				// Jumping while crouching will force an un-crouch but not jump
				player.crouching = 1;
			}
			else if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
			}
			else if (bNoGravity)
			{
				Vel.Z = 3.;
			}
			else if (player.onground && player.jumpTics == 0 || doublejumpready && !oldjump && !alreadyjumped && vel.z < 4)
			{
				double jumpvelz = JumpZ * 35 / TICRATE;
				double jumpfac = 0;

				// [BC] If the player has the high jump power, double his jump velocity.
				// (actually, pick the best factors from all active items.)
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;

				Vel.Z += jumpvelz;
				Vel.z += (vel.xy.length() * 0.25);
				//console.printf("%i",vel.z);
				bOnMobj = false;
				player.jumpTics = -1;
				if (!(player.cheats & CF_PREDICTING)) A_StartSound("*jump", CHAN_BODY);
				If(doublejumpready)
				{
					alreadyjumped = true;
				}
				oldjump = true;
			}
		}
		Else if (oldjump)
		{
			oldjump = false;
		}
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		bool allclear;
		
		If(boostlevel > 1 && other)
		{
			
			other.damagemobj(self,self,100 + boostlevel,"extremepunches");
			if(other && !other.bnodamagethrust && other.mass <  9999)
			{
				float yeetangle = angleto(other);
				other.velfromangle(boostlevel * 5,yeetangle);
				other.vel.z = 6;
				allclear = true;
			}
		}
		
		If(!allclear)
			{
			Return True;
			}
		Else
		{
			Return False;
		}
		
	}
	
	
	bool HookLOS()
	{
		Float LOSPitch = atan2(Rope.XY.Length(), Rope.Z) - 90;
		Float LOSAngle = VectorAngle(Rope.X, Rope.Y);
		FLineTraceData LOSCheck; LineTrace(LOSAngle, Rope.Length(), LOSPitch, TRF_SOLIDACTORS|TRF_BLOCKSELF, Height / 2.f, data: LOSCheck);
		
		if(GrappledMonster != Null && LOSCheck.HitActor == GrappledMonster) { return true; }
		
		return LOSCheck.Distance == Rope.Length();
	}
	
	void GrapplingMove()
	{
		/*if(!brutal_playerbase.OnGround) */{ Grappled = True; }
		
		//Fun is over kids, go home
		if(bNOGRAVITY || Rope.Length() <= 4.f * Radius || !CheckMove(Pos.XY + Vel.XY) || (lasttickrope && rope.length() > (lasttickrope + 30)))
		{
			StopHook();
			return;
		}
		lasttickrope = rope.length();
		
		Usercmd cmd = player.cmd;
			GrappleVel = SafeUnit3(Rope) * GrappleVel.Length();
			Vel = GrappleVel;
			If(cmd.sidemove > 0)
			{
				grapplesidespeed = grapplesidespeed + 2;
			}
			else if(cmd.sidemove < 0)
			{
				grapplesidespeed = grapplesidespeed - 2;
			}
			Acceleration.XY = RotateVector((0, -grapplesidespeed), Angle);
			//
			double currentvel = vel.length();
			vel.xy = (vel.xy + acceleration.xy);
			
			
			//console.printf("%i",rope.length());
			If(!cmd.sidemove && grapplesidespeed > 0)
			{
				grapplesidespeed = grapplesidespeed - 2;
			}
			Else if (!cmd.sidemove && grapplesidespeed < 0)
			{
				grapplesidespeed = grapplesidespeed + 2;
			}
			
	}
	
			
		void StopHook()
	{
		Rope = GrappleVel = (0, 0, 0);
		PendulumLength = 0;
		GrappledMonster = Null;
		grapplesidespeed = 0;
		lasttickrope = 0;
		
	}
		
		//QuakeHandleMove();
		
		//Sprite animation
		//Super.handlemovement();
	
	
	Override void Tick()
    {
	If(findinventory("veh_manager"))
		{
		SetPlayerProperty(0,0,0);
		player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState('InAVehicle'));
		SetStateLabel("invehicle");
		bpickup = false;
		}
		Else
		{
		bpickup = true;
		//if (GetCvar("bd_GenderFemale") == 1) {
		//if (CountInv("GenderFemale") == 1) {
		//	SoundClass = "fplayer";
		//}
		If(CountInv("RollingRight") == 1)
		{
		//player.cheats |= CF_CHASECAM;
		SetStateLabel("rollingright");
		bforcexybillboard = TRUE;
		}
		If(CountInv("RollingLeft") == 1)
		{
		//player.cheats |= CF_CHASECAM;
		SetStateLabel("rollingLeft");
		bforcexybillboard = TRUE;
		}
		If(CountInv("RollFinished") == 1)
		{
		//player.cheats &= ~CF_CHASECAM;
		takeinventory("rollfinished",1);
		bforcexybillboard = FALSE;
		}
		if (CountInv("ExecuteDownedEnemy") == 1)
        {
           TakeInventory("ExecuteDownedEnemy", 10);
		   TakeInventory("GoSpecial", 10);
            player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("DoExecution"));
		//	TakeInventory("ExecuteDownedEnemy", 1);
		//   TakeInventory("GoSpecial", 1);
			SetStateLabel("SpecialChecker");
        }
		
		/*
		if (CountInv("DoStrengthRuneAnim") == 1) {
			TakeInventory("DoStrengthRuneAnim", 1);
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("DoStrengthRuneAnim"));
		}
		*/
		
		If(player && notvoodoo && findinventory("nottitlemap"))
			{
				
		
			let playerArmor = BasicArmor(FindInventory('BasicArmor'));
			If(player && findinventory('ReturnUnmorphStuffPlease'))
				{
				takeinventory('ReturnUnmorphStuffPlease',1);
				
					playerarmor.amount = PreMorpharmor;
					playerArmor.SavePercent = PreMorphArmorPercent;
					a_sethealth(premorphhealth);
				}
	
		
			PreMorphArmor = playerarmor.amount;
			PreMorphArmorPercent =	playerArmor.SavePercent;
			PreMorphHealth = health;
			
			}
			
		}
		super.Tick();
    }
	
	
	//////////////////////////////////////
	// Ledge Grab						//
	//////////////////////////////////////
	
	void LedgeGrabInitiator()
	{
		ZMPlayer = self.player;
		
		//Already ledge grabbing, no clipping, moving away from where you are looking, ceiling already too low for sure
		if((pos.z <= floorz) || LedgeCheck || LedgeGrabbed || (ZMPlayer.Cheats & CF_NOCLIP2) || Vel.XY dot AngleToVector(Angle) <= 0 || CeilingZ <= Pos.Z + Height * 1.6f) { return; }
		
		//============================================
		//Find ledge (if any)						//
		//============================================
		
		FLineTraceData LedgeTrace;
		Float TraceDistance = sqrt(2) * Radius + 1; //account for the fact that Doom's hitboxes are square
		LineTrace(Angle, TraceDistance, 0, TRF_BLOCKSELF|TRF_THRUACTORS, Height * 1.2f, data: LedgeTrace);
		Vector3 HitPos = LedgeTrace.HitLocation;
		
		Int LedgeCandidate;
		if(LedgeTrace.HitType == TRACE_HitWall) //hit wall scenario
		{
			if(LedgeTrace.Hit3DFloor != NULL) //3D floor
			{
				LedgeCandidate = LedgeTrace.Hit3DFloor.Top.ZAtPoint(HitPos.XY);
			}
			else //regular wall
			{
				Line HitLine = LedgeTrace.HitLine;
				if(HitLine.FrontSector != NULL && HitLine.FrontSector != CurSector)
					LedgeCandidate = HitLine.FrontSector.FloorPlane.ZatPoint(HitPos.XY);
				else if(HitLine.BackSector != NULL && HitLine.BackSector != CurSector)
					LedgeCandidate = HitLine.BackSector.FloorPlane.ZatPoint(HitPos.XY);
			}
		}
		else if(LedgeTrace.HitSector != CurSector)//tracer stopper mid air in a sector that is not the one where player currently is
		{
			LedgeCandidate = LedgeTrace.HitSector.NextLowestFloorAt(HitPos.X, HitPos.Y, HitPos.Z, FFCF_3DRESTRICT, 0);
		}
		else
		{
			return;
		}
		
		//Check if the candidate ledge can suffice
		if(LedgeCandidate > Pos.Z + Height * 0.6f && LedgeCandidate <= Pos.Z + Height * 1.2f)
		{
			Vector3 OrigPos = Pos;
			SetXYZ((Pos.XY, LedgeCandidate));
			if(!CheckMove(Pos.XY + 5.f * AngleToVector(Angle))) //not enough space, cancel everything :(
			{
				SetXYZ(OrigPos);
				return;
			}
			SetXYZ(OrigPos);
			LedgeHeight = LedgeCandidate;
			LedgeHeightMin = (LedgeHeight - Height * 0.97f);
			LedgeHeightMax = (LedgeHeight - Height * 0.751f);
		}
		else
		{
			return; //too high/low
		}
		
		/*
		LineTrace(Angle, TraceDistance, 0, TRF_BLOCKSELF|TRF_THRUACTORS|TRF_NOSKY, 0, data: LedgeTrace);
		if (LedgeTrace.HitLine && LedgeTrace.hittype == TRACE_HITWALL) 
		{
			double lineangle = atan2(LedgeTrace.HitLine.delta.y, LedgeTrace.HitLine.delta.x); //angle of the line
			double targangle = lineangle + 90; //this will be the angle of the player
			
			if(targangle < 0) 
			{
				targangle = -(targangle + 90);
			}
			if (LedgeTrace.LineSide)
			{
				targangle *= -1; //reverse it if you're facing the back side of the linedef
			}
			A_SetAngle(targangle,SPF_INTERPOLATE); //set player's angle
		}
		*/
		
		//============================================
		//Abemus ledge, execute						//
		//============================================
		
		//Switch to a weapon that forbids firing during the ledge grab
		
		/*
		//Reset dash stuff just in case
		//MaxAirSpeed = ADashTargetSpeed;
		//DashCooler = ADashCooler = ADashTargetSpeed = WJumpSpeed = DashNumber = 0;
		*/
		
		//Credit Cherno
		//Console.Printf("Num: %f", LedgeHeight);
		
		velz = 8;
		LedgeCheck = True;
		
		if(vel.length() < 5)
		{
			GiveInventory("Grabbing_A_Ledge", 1);
		}
		if(pos.z >= (LedgeHeightMin+20))
		{
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("FinishClimb"));
			
			A_StopSound(CHAN_WEAPON);
			A_StartSound("ledgeclimb");
			LedgeAngle = Angle;
			LedgeCheck = False;
			LedgeGrabbed = True;
			return;
		}
		if((player.readyweapon is "Melee_Attacks") || (player.readyweapon is "Chain_saw") || (player.readyweapon is "BrutalAxe"))
		{
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("StainedLedgeClimb"));
		}
		else
		{
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("LedgeClimb"));
		}
	}
	void LedgeReach()
	{
		LedgeTime++;
		if(LedgeTime >= 30)
		{
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
			LedgeGrabbed = LedgeTime = LedgeHeight = LedgeHeightMin = LedgeHeightMax = FrameTime = 0;
		}
	}
	
	void LedgeGrab()
	{
		if(Pos.Z >= LedgeHeight || !Vel.Length() || LedgeTime >= 35)
		{
			//End Ledge Grab
			LedgeCheck = False;
			SetOrigin((Pos.X, Pos.Y, LedgeHeight), True);
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
			
			//Only if ledge grab was successful
			if(LedgeTime >= 35) { return; }
			LedgeGrabbed = LedgeTime = LedgeHeight = LedgeHeightMin = LedgeHeightMax = FrameTime = 0;
			Vel = Vel.Length() ? (5.f * AngleToVector(LedgeAngle), -3) : (0, 0, 0); //push player forward and downward
			A_StartSound("*land", CHAN_BODY);
		}
		else
		{
			Vel = Vel.Length() ? (0, 0, 8) : (0, 0, 0);
		}
		
		//Fail safe to unlock player movement if something goes wrong
		LedgeTime++;
		if(LedgeTime >= 35)
		{
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
			LedgeGrabbed = LedgeTime = LedgeHeight = LedgeHeightMin = LedgeHeightMax = FrameTime = 0;
		}
		
		//Sprite animation
		PlayIdle();
	}
}


Class Hook : Actor
{
	Default
	{
		+FORCEXYBILLBOARD;
		+HITMASTER;
		+MISSILE;
		+NOGRAVITY;
		+NOTELEPORT;
		//+alwayspuff;
		+puffonactors;
		+NOTONAUTOMAP;
		+THRUSPECIES;
		//+seekermissile;
		//+screenseeker;
		//+doombounce;
		//+bounceonfloors;
		//+bounceonwalls;
		+dontcorpse;
		+explodeonwater;
		//+noclip;
		Damagefunction 0;
		+nodamagethrust;
		Height 4;
		Radius 10;
		Speed 1;
		Species "Hook";
		+puffgetsowner;
	//	+forcepain; 
		//bouncefactor 0.1;
		+NOTIMEFREEZE;
	}
	
	vector3 HookToPlayer;
	vector3	HookToMonster;
	int		MonsterSpeed;
	int		MonsterFloatSpeed;
	float maxdistnew;
	//bool bisflaming;
	
	vector3 SafeUnit3(Vector3 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	vector2 SafeUnit2(Vector2 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	Override void Tick()
	{
		//bool isflaming = false;
		Let HookOwner = brutal_playerbase(Target);
		if(HookOwner)
		{
			Vector3 WaistPos = (HookOwner.Pos.X, HookOwner.Pos.Y, HookOwner.Pos.Z + HookOwner.Height / 2.f); // player position
			HookToPlayer = Pos - WaistPos; //hook-to-player vector
			
		}
		
		Super.Tick();
		
		UpdateTrail();
	}
	
	void UpdateTrail()
	{
		int b;
		for(b = 1; b <= 14; b++)
		{
			ActorIterator BallOfSteele = Level.CreateActorIterator(84115 + b);
			Actor Ball = BallOfSteele.Next();
			
			if(Ball != Null)
			{
				//Set trail velocity
				Vector3 TargetPos = Pos - (HookToPlayer * b / 15.f);
				Ball.Vel = TargetPos - Ball.Pos;
			}
		}
	}
	
	void InitiateGrapple(Bool Monster)
	{
		Let HookOwner = brutal_playerbase(Target);
		
		Float	PushLength = 4 * 5.5;
		Vector3 HookPush = SafeUnit3(HookToPlayer) * PushLength;
		Float 	HookSpeed = max((HookPush).Length(), PushLength);
		HookOwner.Rope = HookToPlayer; //needed for the LOS check
		
		//Check hook is still in sight
		//if(!HookOwner.HookLOS())
		//{
		//	SetState(FindState("DespawnHook"));
		//	return;
		//}
		
		//Stop any eventual wall slides
		/*
		HookOwner.StopWSlide();
		
		//Stop dashing stuff
		HookOwner.ADashCooler = HookOwner.ADashTargetSpeed = 0;
		
		//Initiate hook
		*/
		HookSpeed = HookOwner.MaxAirSpeed = min(HookSpeed, 24);
		HookOwner.Vel = HookOwner.GrappleVel = HookSpeed * SafeUnit3(HookPush);
		
		//Hooking monsters specific
		if(Monster)
		{
			Let Monster = Actor(Master);
			If(!monster.bnoblood)
			{
			Monster.spawnblood(pos,angle,1);
			}
			monster.a_pain();
			brutal_playerbase(Target).GrappledMonster = Monster;
			SetMonsterSpeed(False);
			A_StartSound("HookMeat", 7);
		}
		else
		{
			A_StartSound("HookWall", 7);
		}
	}
	
	void SetMonsterSpeed(Bool Reset)
	{
		Let Monster = Actor(Master);
		/*
		if(!Reset)
		{
			MonsterSpeed = Monster.Speed;
			MonsterFloatSpeed = Monster.FloatSpeed;
			Monster.Speed = Monster.FloatSpeed = 0;
		}
		else
		{
			Monster.Speed = MonsterSpeed;
			Monster.FloatSpeed = MonsterFloatSpeed;
		}
		*/
	}
	
	void SpawnTrail()
	{
		int h;
		for(h = 1; h <= 14; h++)
		{
			
			A_SpawnItemEx("HookTrail",0,0,0,0,0,0,0,SXF_ISTRACER|SXF_SETTARGET|SXF_ORIGINATOR|SXF_NOCHECKPOSITION);
			
			
			Let SlaveTrail = HookTrail(Tracer);
			SlaveTrail.ChangeTid(84115 + h);
		}
	}
	
	
	

	
	States
	{
	//====================================
	//Hook is traveling through space
	Spawn:
		OCLW A 0 NoDelay
		{
			Let HookOwner = brutal_playerbase(Target);
			A_AlertMonsters();
			
			 if (target && target.target)
			 {//ensure that the shooter even has a target
            SetOrigin(target.target.pos+(0,0,target.target.height*0.5),false);
			target.a_cleartarget();
			}
			SpawnTrail();
			//HookOwner.a_takeinventory("meathook",1);
			
		}
	Looper:
		OCLW A 1
		{
			//a_seekermissile(365,365,SMF_LOOK);
			Let HookOwner = brutal_playerbase(Target);
			//target.giveinventory("meathook",1);
			//Despawn if no geometry was found
			/*
			if(HookToPlayer.Length() >= 1300.f || !HookOwner)
			{
				SetState(FindState("Death"));
				return;
			}
			*/
		}
		Goto despawnhook;
	
	//====================================
	//Hook hit a wall or ceiling

	
	
	TillDeathDoesUsApart:
		OCLW A 1
		{
			Let HookOwner = brutal_playerbase(Target);
			if(!HookOwner.GrappleVel.Length() || !HookOwner)
			{
				SetState(FindState("DespawnHook"));
				return;
			}
			
			if(HookOwner)
		{
			Vector3 WaistPos = (HookOwner.Pos.X, HookOwner.Pos.Y, HookOwner.Pos.Z + HookOwner.Height / 2.f); // player position
			HookToPlayer = Pos - WaistPos; //hook-to-player vector
			
			
		}
		
		
		UpdateTrail();
			
			HookOwner.Rope = HookToPlayer;
		}
		Loop;
		
	//====================================
	//Hit actor
	XDeath:
	//Melee:
		OCLW A 1
		{

			
			Let HookOwner = brutal_playerbase(Target);
			//SpawnTrail();
			Let Monster = Actor(Master);
			
		
			
			InitiateGrapple(True); 
			maxdistnew = HookToPlayer.length();
		}
	
	TillXDeathDoesUsApart:
		OCLW A 1
		{
			Let HookOwner = brutal_playerbase(Target);
			Let Monster = Actor(Master);
			If (monster)
			{
			setorigin(monster.pos+(0,0,monster.height*0.5),TRUE);
			}
			
			if(!HookOwner || !HookOwner.GrappleVel.Length() || !Monster || Monster.health <=0)
			{
				return resolvestate("despawnhook");
			}
			
			
				if(HookOwner)
		{
			Vector3 WaistPos = (HookOwner.Pos.X, HookOwner.Pos.Y, HookOwner.Pos.Z + HookOwner.Height / 2.f); // player position
			HookToPlayer = Pos - WaistPos; //hook-to-player vector
			
			
			
			
		}
		
		
		UpdateTrail();
			
			
			a_startsound("MHKLOOP",194,CHANF_LOOPING,0.5,ATTN_NONE);
			/*
			if (monster.FindState('Pain.meathook') && !monster.bdormant && !monster.bnopain && !monster.findinventory("glorykillme") && !monster.findinventory("enemyisarchvile"))
			{
			Monster.setstatelabel("pain.meathook");
			}
			Else if (monster.FindState('Pain') && !monster.bdormant && !monster.bnopain && !monster.findinventory("glorykillme") && !monster.findinventory("enemyisarchvile"))
			{
			Monster.setstatelabel("pain");
			}
			*/
			
			
			Vel = Monster.Vel;
			HookOwner.Rope = HookToPlayer;
			Return resolvestate(null);
		}
		Loop;
		
	//====================================
	//Die Monster! You don't belong in this world
	Death:
	OCLW AAA 0
		{
			Let HookOwner = brutal_playerbase(Target);
			if(HookOwner)
			{
			//	HookOwner.a_giveinventory("canfiremeathook",1);
				HookOwner.StopHook();
			//	HookOwner.a_giveinventory("meathook",1);
				//HookOwner.a_startsound("weapons/empty",194,CHANF_DEFAULT,1,ATTN_NONE);
			}
			a_stopsound(194);
			Let Monster = Actor(Master);
			if(Monster && MonsterSpeed) { SetMonsterSpeed(True); }
		}
		Stop;
		
	DespawnHook:
		OCLW A 0
		{
			Let HookOwner = brutal_playerbase(Target);
			if(HookOwner)
			{
				HookOwner.StopHook();
			//	HookOwner.a_giveinventory("canfiremeathook",1);
			//	HookOwner.a_giveinventory("meathook",1);
				HookOwner.a_startsound("MHKSTP",194,CHANF_DEFAULT,1,ATTN_NONE);
			}
			a_stopsound(194);
			Let Monster = Actor(Master);
			if(Monster && MonsterSpeed) { SetMonsterSpeed(True); }
		}
		Stop;
	}
}

Class HookTrail : Actor
{
	Default
	{
		+FORCEXYBILLBOARD;
		+MISSILE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NOTONAUTOMAP;
		+THRUSPECIES;
		+ExplodeOnWater;
		Radius 2;
		Height 4;
		Scale 0.5;
		Species "HookTrail";
		+NOTIMEFREEZE;
	}
	
	States
	{
		Spawn:
		Looper:
			TEND A 1
			{
				if(!Hook(Target))
				{
					SetState(FindState("DespawnTrail"));
					return;
				}
				
			
			}
			Loop;
			
		Death:
			TEND A 1
			{
				if(!Hook(Target))
				{
					SetState(FindState("DespawnTrail"));
					return;
				}
			}
			Loop;
			
		DespawnTrail:
			Stop;
	}
}

Class Speedline : Actor
{
	Default
	{
		+nogravity;
		Renderstyle "Add";
		Alpha 0.2;
	}
	
	States
	{
		Spawn:
			TRAC A 3;
			Spawn2:
			TRAC A 1 A_FadeOut(0.30);
			LOOP;
	
	}

}