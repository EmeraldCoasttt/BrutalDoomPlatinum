class GunfireParticle : VisualThinker
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		texture = TexMan.CheckForTexture('SPKOB0');
		scale = (0.1,0.1);
		alpha = 1;
		flags = SPF_FULLBRIGHT;
		SetRenderStyle(STYLE_Add);
	}
	
	override void Tick()
	{
		if(alpha <= 0)
		{
			Destroy();
		}
		vel.z -= 0.6;
		alpha -= 0.04;
		Super.Tick();
	}
}

class ShieldParticle : VisualThinker
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		texture = TexMan.CheckForTexture('SPKGA0');
		scale = (0.01,0.01);
		alpha = 1;
		flags = SPF_FULLBRIGHT;
		SetRenderStyle(STYLE_Add);
	}
	
	override void Tick()
	{
		if(alpha <= 0)
		{
			Destroy();
		}
		vel.z -= 0.2;
		alpha -= 0.04;
		Super.Tick();
	}
}

Class BDPWeaponBase : DoomWeapon //Weapon
{
	int BDPWeaponFlags;
	flagdef BloodStain : BDPWeaponFlags, 0;
	flagdef DualWeapon : BDPWeaponFlags, 1;
	
	int aimMode;
	bool scopeZoom;
	int aimTics;
	
	bool dualWield;
	bool initDual;
	bool switchingDual;
	bool sideFired;
	bool readyRight;
	bool readyLeft;
	name dualWeapon;
	property DualWeapon : dualWeapon;
	ui double curbob;
	
	bool firing;
	bool altFiring;
	
	statelabel fidgetState;
	
	int sprinttimer;
	int Handedness; 
	property Handedness : Handedness;
	bool lasttickfatality;
	Bool offhandkick;
	Property offhandkick : offhandkick;
	Bool clearoverlays;
	Property clearoverlays : clearoverlays;
	Bool VoiceActed;
	Property VoiceActed : VoiceActed;
	
	int semiautofired;
	bool semiclear;
	
	bool dryFired;
	
	Actor GuidedLaser;
	
	//Modifiers:
	bool gunslinger;
	int gunslingertics;
	bool gunslingereligible;
	bool gunslinger2;
	
	//name gunslingerammoname;
	name gunslingermagname;
	int gunslingermagsize;
	
	name AmmoType3;
	Property AmmoType3 : AmmoType3;
	
	int mag;
	int MagCapacity;
	Property MagCapacity : MagCapacity;
	vector2 magConversion;
	Property MagConversion : magConversion;
	
	bool newweapon;
	
	int bloodStain;
	
	bool ForceSelect;
	Property ForceSelect : ForceSelect;
	
	bool asgshieldactive;
	
	Default
	{
	BDPWeaponBase.Handedness 0;
	Weapon.AmmoUse 0;
	Weapon.BobRangeX 0.2;
	Weapon.BobRangeY 0.4;
	Weapon.BobSpeed 2.1;
	Weapon.BobStyle "InverseSmooth";
	BDPWeaponBase.clearoverlays TRUE;
	BDPWeaponBase.VoiceActed TRUE;
	//Radius 32;
	+WEAPON.NOAUTOAIM
	+WEAPON.NOAUTOFIRE
	+WEAPON.NOALERT
	+NOBLOOD
	}
	
	override void beginplay()
	{
		mag = magcapacity;
		if(magConversion == (0,0))
		{
			magConversion = (1,1);
		}
		Super.beginplay();
	}
	
	override void ondrop(Actor dropper)
	{
		giveinventory("AmmoTaken",1);
		
		If(self is "BDPSubmachineGun")
		{
			If(dropper.findinventory("BDPDualSMG"))
			{
				giveinventory("BDPSubmachineGun",1);
				Inventory drop = FindInventory("BDPSubmachineGun");
				Self.DropInventory(Drop,1);
			}
			
			Dropper.takeinventory("BDPDualSMG",1);
		}
		If(self is "BDPRevolver")
		{
			If(dropper.findinventory("BDPDualRevolver"))
			{
				giveinventory("BDPRevolver",1);
				Inventory drop = FindInventory("BDPRevolver");
				Self.DropInventory(Drop,1);
			}
			
			Dropper.takeinventory("BDPDualRevolver",1);
		}
		If(self is "BDPPlasmaRifle")
		{
			If(dropper.findinventory("BDPDualPlasmaRifle"))
			{
				giveinventory("BDPPlasmaRifle",1);
				Inventory drop = FindInventory("BDPPlasmaRifle");
				Self.DropInventory(Drop,1);
			}
			
			Dropper.takeinventory("BDPDualPlasmaRifle",1);
		}
		
	}
	
	override state GetDownState()
	{
		owner.player.SetPSprite(49,null);
		owner.player.SetPSprite(50,null);
		return resolvestate("Deselect");
	}
	
	override state GetUpState()
	{
		return resolvestate("InitWeaponState");
	}
	action void A_KeepSprinting(int flags = 0) {}
	override state GetAtkState(bool hold)
	{
		owner.player.SetPSprite(49,null);
		owner.player.SetPSprite(50,null);
		firing = true;
		if(aimMode > 0)
			return resolvestate("FireAim");
		return resolvestate("Fire");
	}
	
	override state GetAltAtkState(bool hold) 
	{
		let dplr = BDPPlayerPawn(owner);
		if(aimMode == 1 && !dplr.blockAltfire)
		{
			owner.player.SetPSprite(49,null);
			owner.player.SetPSprite(50,null);
			dplr.blockAltfire = true;
			return resolvestate("AimEnd");
		}
		if(resolvestate("Altfire"))
		{
			owner.player.SetPSprite(49,null);
			owner.player.SetPSprite(50,null);
			altFiring = true;
			return resolvestate("Altfire");
		}
		return resolvestate(null);
	}
	
	override Vector2 ModifyBobLayer(Vector2 Bob, int layer, double ticfrac)
	{
		let dplr = PlayerPawn(owner);
		if(layer == 2 && owner.player && dplr)
		{
			if (self.bDontBob || owner.player.GetWBobSpeed() == 0)
			{
				return (0, 0);
			}
			vector2 p1, p2, r;
			for (int i = 0; i < 2; i++)
			{
				if (curbob != owner.player.bob)
				{
					if (abs(owner.player.bob - curbob) <= 1)
					{
						curbob = owner.player.bob;
					}
					else
					{
						double zoom = MAX(1., abs(curbob - owner.player.bob) / 40);
						if (curbob > owner.player.bob)
						{
							curbob -= zoom;
						}
						else
						{
							curbob += zoom;
						}
					}
				}
				double BobSpeed = (BobSpeed * 128);
				double angle = (BobSpeed * owner.player.GetWBobSpeed() * 35 /	TICRATE*(10 - 1 + i)) * (360. / 8192.);
				double BobIntensity = (owner.player.WeaponState & WF_WEAPONBOBBING) ? 1. : owner.player.GetWBobFire();
				if (curbob != 0)
				{
				double bobx = (owner.player.bob * BobIntensity * BobRangeX * owner.player.mo.ViewBob);
				double boby = (owner.player.bob * BobIntensity * BobRangeY * owner.player.mo.ViewBob);
				
				r.X = bobx*sin(angle);
				r.Y = 0.5f * (boby * (1. - (cos(angle * 2))));
				}
				else
				{
					r = (0, 0);
				}
				if (i == 0) p1 = r; else p2 = r;
			}
			return p1 * (1. - ticfrac) + p2 * ticfrac;
		}
		return Bob;
	}
	
	action void a_weaponvoiceline()
	{
		If(!invoker.newweapon && invoker.voiceacted)
		{
			let dplr = BDPPlayerPawn(invoker.owner);
			if(dplr)
			{
				dplr.newweapon = true;
			}
			invoker.newweapon = true;
		}
	
	}
	
	action void A_DiscardMag(int chamber = 0)
	{
		let dplr = BDPPlayerPawn(invoker.owner);
		if(dplr && dplr.gluttony)
		{
			Until(invoker.mag <= chamber)
			{
				invoker.mag--;
			}
		}
	}
	
	action void A_SetCrosshairDX(string crosshairname, int crosshairrange = 5000, double crosshairscale = 1.0)
	{
		let dplr = BDPPlayerPawn(invoker.owner);
			if(dplr)
			{
				dplr.crosshair = crosshairname;
				dplr.crosshairscale = (crosshairscale,crosshairscale);
				dplr.crosshairrange = crosshairrange;
			}
	
	}
	
	action void A_QuadSound()
	{	
		If(invoker.owner.findinventory("PowerQuakeDamage"))
		{
			invoker.owner.a_startsound("items/quaddamage/active", 103);
		}
	}
	
	action void A_FirePitchDown(sound soundname = "PLSM9", int soundchannel = 1, double ammocount = 8, name ammotype = "PlasmaAmmo")
	{
		If(invoker.mag > ammocount)
		{
			invoker.owner.a_startsound(soundname,soundchannel);
		}
		Else
		{
			float soundpitch;
			soundpitch = (invoker.mag / (ammocount * 5));
			soundpitch = (0.8 + soundpitch);
			
			invoker.owner.a_startsound(soundname,soundchannel, PITCH: soundpitch);
		}
	}
	
	int guntimertics;
	action void A_GunLight(int intensity = 500, int alivetime = 2, int lightr = 255, int lightg = 237, int lightb = 162)
	{
		if(getcvar("BDP_GunLight") == true)
		{
			BDP_Gunlight SelfLight1 = BDP_Gunlight(Spawn("BDP_Gunlight",(invoker.owner.pos.x, invoker.owner.pos.y, invoker.owner.pos.z + invoker.owner.player.viewheight),false));
			SelfLight1.args[DynamicLight.LIGHT_RED] = lightr; //R
			SelfLight1.args[DynamicLight.LIGHT_GREEN] = lightg; //G
			SelfLight1.args[DynamicLight.LIGHT_BLUE] = lightb; //B
			SelfLight1.args[DynamicLight.LIGHT_INTENSITY] = intensity; //Intensity
			SelfLight1.SpotInnerAngle = 60;
			SelfLight1.SpotOuterAngle = 90;
			SelfLight1.angle = invoker.owner.angle;
			SelfLight1.pitch = invoker.owner.pitch;
			SelfLight1.alivetime = alivetime;
		}
	}
	
	//Lewisk3 :3
	
	action Actor A_BDPMelee(double range = 200, name projectile = "MeleeAttack", double spawnheight = -7, bool doHitThrust = true)
	{
		Actor Victim;
		
			FLineTraceData lt;
			double aimz = self.player ? self.player.viewheight : (self.height * 0.5);
			self.LineTrace(self.angle, range, self.pitch, 0, aimz, data:lt);
			victim = lt.HitActor;
			int aimCheck = -6;
			bool backsmack;
		
		
			while (aimCheck++ < 6 && !victim)
			{
				self.LineTrace(self.angle + (aimCheck * 8), range, self.pitch, 0, aimz, data:lt);
			victim = lt.hitActor;
			}
			
			
		
			
		
		if(victim && victim.bSHOOTABLE) 
		{
			
			vector3 victimAngles = level.sphericalCoords(victim.pos, self.pos, (victim.angle, victim.pitch));
			

			
			double inertia = BDPMath.GetInertia(victim.mass);
			self.A_Quake(2,3,0,20,"");
			self.A_face(victim);
			if(doHitThrust && victim.bsolid)
			{
				self.vel *= 0;
				self.vel += BDPMath.VecFromAngles(self.angle, self.pitch, -12);	
			}
						
		}
		actor proj = A_FireProjectile(projectile, 0, 0, 0, spawnheight);
			If(proj && victim && victim.bSHOOTABLE)
			{
				proj.setorigin(victim.pos,false);
			}
		
		return victim;
	}
	
	action void A_ReloadMag(int chamber = 0, bool additive = false, bool free = false)
	{
		int MagGoal = invoker.MagCapacity;
		if(additive)
		{
			MagGoal = invoker.mag + invoker.magConversion.x;
		}
		int SecondaryMagGoal;
		if(invoker.mag > 0)
		{
			MagGoal += chamber;
		}
		while(invoker.mag < MagGoal && countinv(invoker.AmmoType1) >= invoker.magConversion.y)
		{
			if(!free)
			{
				takeinventory(invoker.AmmoType1,invoker.magConversion.y);
			}
			invoker.mag += invoker.magConversion.x;
			invoker.mag = clamp(invoker.mag,0,MagGoal);
			//If(secondarymag && countinv(secondarymag) < SecondaryMagGoal)
			//{
			//	giveinventory(secondarymag,1);
			//}
		}
	}
	
	action void A_HandleDualFiring(statelabel firestate, statelabel altstate = null, bool sprinting = false)
	{
		let dplr = BDPPlayerPawn(invoker.owner);
		if(OverlayID() == 3)
			invoker.readyRight = false;
		if(OverlayID() == 2)
			invoker.readyLeft = false;
		if(OverlayID() == 3 && !invoker.sideFired || OverlayID() == 2 && invoker.sideFired)
		{
			if(firestate && !dplr.blockFire && player.cmd.buttons & BT_ATTACK)
			{
				invoker.sideFired = !invoker.sideFired;
				dplr.blockFire = true;
				player.SetPSprite(OverlayID(),resolvestate(firestate));
				return;
			}
			if(altstate && !dplr.blockAltfire && player.cmd.buttons & BT_ALTATTACK)
			{
				invoker.sideFired = !invoker.sideFired;
				dplr.blockAltFire = true;
				Player.SetPSprite(OverlayID(),resolvestate(altstate));
				return;
			}
		}
		if(invoker.CheckSprint() && !sprinting)
		{
			if(OverlayID() == 3)
				player.SetPSprite(3,resolvestate("SprintRight"));
			if(OverlayID() == 2)
				player.SetPSprite(2,resolvestate("SprintLeft"));
		}
		if(OverlayID() == 3)
			invoker.readyRight = true;
		if(OverlayID() == 2)
			invoker.readyLeft = true;
		return;
	}
	
	action void A_DrawDualOverlays(statelabel left, statelabel right, bool flip = false, bool nooverride = false)
	{
		if(left)
		{
			A_Overlay(2,left,!invoker.readyLeft || nooverride);
			if(flip)
				A_OverlayFlags(2,PSPF_FLIP|PSPF_MIRROR,true);
		}
		if(right)
			A_Overlay(3,right,!invoker.readyRight || nooverride);
	}
	
	action int DualMag()
	{
		let weap = BDPWeaponBase(FindInventory(invoker.DualWeapon));
		return weap.mag;
	}
	
	action void A_ReloadDualMag(int chamber = 0, bool additive = false, bool free = false)
	{
		let weap = BDPWeaponBase(FindInventory(invoker.DualWeapon));
		if(CountInv(invoker.ammotype1) < weap.magCapacity) {
			int touse = CountInv(invoker.ammotype1) / 2;
			TakeInventory(invoker.ammotype1,touse);
			weap.A_ReloadMag(chamber,additive,free);
			GiveInventory(invoker.ammotype1,touse);
		}
		else
			weap.A_ReloadMag(chamber,additive,free);
	}
	
	action void A_DiscardDualMag(int chamber = 0)
	{
		let weap = BDPWeaponBase(FindInventory(invoker.DualWeapon));
		weap.A_DiscardMag(chamber);
	}
	
	action void A_TakeDualMag(int ammoamount = 1, bool take = true, bool force = false)
	{
		let weap = BDPWeaponBase(FindInventory(invoker.DualWeapon));
		weap.A_TakeMag(ammoamount,force);
	}
	
	action state A_CheckIfDualMag(int ammoamount = 1, statelabel label = "NoAmmo", bool force = false)
	{
		let weap = BDPWeaponBase(FindInventory(invoker.DualWeapon));
		if(weap.mag >= ammoamount || (findinventory("PowerSpeed2") && !force))
			Return ResolveState(null);
		else
			Return resolvestate(label);
	}
	
	action void A_DualMagClick(string sound = "weapons/empty")
	{
		let weap = BDPWeaponBase(FindInventory(invoker.DualWeapon));
		double current = weap.mag;
		double max = weap.magCapacity / 4;
		if(current <= max && CVar.GetCVar("bd_maggoclicky",player).GetBool() == true)
			A_StartSound(sound,3);
	}
	
	action void A_gunslingermag(int chamber = 0)
	{
		If(invoker.gunslinger && invoker.gunslingereligible)
		{
			A_reloadMag(chamber);
		}
		invoker.gunslingereligible = false;
		//Invoker.gunslingerammoname = ammopool;
	}
	
	action void A_BDPMeleeStart(double range = 200)
	{
	//if(A_CheckMeleeRange(skipWalls:true) < range) A_Recoil3D(-20); 
		FLineTraceData lt;
			LineTrace(angle, range, pitch, 0, player.viewheight, data:lt);
			If(lt.hitactor && lt.hitactor.bsolid)
			{
				A_face(lt.hitactor,0,0,0,0,FAF_MIDDLE);
				A_Recoil3D(-20);
			}
	}
	
	action double A_CheckMeleeRange(double maxrange = 512, bool skipWalls = false)
	{
		FLineTraceData lt;
		LineTrace(angle, maxrange, pitch, 0, player.viewheight, data:lt);
		return (skipWalls && !lt.hitActor) ? maxrange : lt.Distance;
	}
	
	action void A_Recoil3D(double amt)
	{
		vel += BDPMath.VecFromAngles(angle, pitch, -amt);
	}
	
	//Is BT_Reload cursed? Why doesn't it register the input?
	//I feel like I'm going insane
	//Emerald 11/7/2025
	
	//Oh my god it was just brutal doom jank FUCK
	action state A_PressingReload(statelabel reloadstate = "reload")
	{
		if ((player.cmd.buttons & BT_RELOAD) || (player.oldbuttons & BT_RELOAD))
		{
			//console.printf("YeeHaw");
			return resolvestate(reloadstate);
		}
		Else 
		{
			return resolvestate(null);
		}
	}
	
	action void a_SpawnLaser(class<Actor> Spawntype)
	{
		FLineTraceData lasersight;
		invoker.owner.LineTrace(invoker.owner.angle, 4096, invoker.owner.pitch, TRF_SOLIDACTORS|TRF_THRUHITSCAN, offsetz: invoker.owner.player.viewz - invoker.owner.pos.z, data: lasersight);
		vector3 targetpos = lasersight.HitLocation;
		if (lasersight.HitLine)
		{
			vector2 wallnormal = (-lasersight.HitLine.delta.y,lasersight.HitLine.delta.x).unit();
			if (!lasersight.LineSide)
			wallnormal *= -1;
			targetpos += (wallnormal * 18);
		}
		/*
		if (lasersight.hittype == trace_hitceiling)
				{
					targetpos.z -= 2;
				}
		if (lasersight.hittype == trace_hitfloor)
				{
					targetpos.z += 2;
				}
				*/
		Spawn(spawntype,targetpos);
	
	}
	
	action void A_TakeAmmo(class<Inventory> ammotype, int ammoamount = 1, bool force = false)
	{
		If(!findinventory("powerspeed2") || force)
		{
			ammoamount > 0 ? A_TakeInventory(ammotype,ammoamount) : A_GiveInventory(ammotype,ammoamount);
		}
	}
	
	action void A_TakeMag(int ammoamount = 1, bool force = false)
	{
		if(!findinventory("powerspeed2") || force)
		{
			invoker.mag -= ammoamount;
		}
	}
	
	action void A_StartAim(double zoomfactor, string insound = "ADSIN")
	{
		A_StartSound(insound);
		A_ZoomFactor(zoomfactor);
		switch(CVar.GetCVar("bd_Aim",player).GetInt())
		{
		case 0:
			invoker.aimTics = 5;
			invoker.aimMode = 2;
			break;
		case 1:
			invoker.aimMode = 1;
			break;
		case 2:
			invoker.aimMode = 2;
			break;
		}
	}
	
	action void A_HandleScope(double lowfactor, double highfactor, string insound = "ADSIN", string outsound = "ADSOUT")
	{
		let dplr = BDPPlayerPawn(invoker.owner);
		if(player.cmd.buttons & BT_USER3 && !dplr.blockSpecial && !invoker.scopeZoom)
		{
			dplr.blockSpecial = true;
			A_StartSound(insound);
			invoker.scopeZoom = true;
		}
		else if(player.cmd.buttons & BT_USER3 && !dplr.blockSpecial && invoker.scopeZoom)
		{
			dplr.blockSpecial = true;
			A_StartSound(outsound);
			invoker.scopeZoom = false;
		}
		A_ZoomFactor(invoker.scopeZoom ? highfactor : lowfactor);
	}
	
	action void A_EndAim(string outsound = "ADSOUT")
	{
		if(invoker.aimMode > 0)
		{
			A_StartSound(outsound);
			invoker.aimMode = 0;
			A_ZoomFactor(1.0);
		}
	}
			
	action void A_FireVisualThinker(class<VisualThinker> thinker, int speed = 0, double offsetangle = 0, double offsetpitch = 0, double offsetx = 0, double offsety = 0, double offsetz = 0, bool rvel = true)	
	{
		let thonk = Level.SpawnVisualThinker(thinker);
		if(thonk)
		{
			BDPGMQuaternion base = BDPGMQuaternion.createFromAngles(angle,pitch,roll);
			BDPGMQuaternion angl = BDPGMQuaternion.createFromAngles(offsetangle,0,0);
			BDPGMQuaternion ptch = BDPGMQuaternion.createFromAngles(0,offsetpitch,0);
			BDPGMQuaternion rotated = base.multiplyQuat(angl).multiplyQuat(ptch);
			Vector3 dir;
			[dir.x, dir.y, dir.z] = rotated.toAngles();
			quat ofsbase = Quat.FromAngles(angle, pitch, roll);
			Vector3 offset = (offsety, -offsetx, offsetz);
			Vector3 ppos = ofsbase * offset;
			Vector3 ofs = level.Vec3Offset(pos, ppos);
			thonk.pos = ofs;
			thonk.pos.z += player.mo.height * 0.5 - player.mo.floorclip + player.mo.AttackZOffset*player.crouchFactor - 4 + offsetz; //i want to die
			invoker.Vel3DFromAngle(speed,dir.x,dir.y);
			thonk.vel = invoker.vel;
			invoker.Vel3DFromAngle(clamp(speed/2,0,player.mo.radius),dir.x,dir.y);
			thonk.pos += invoker.vel;
			if(rvel)
			{
				thonk.vel += player.mo.vel;
			}
		}
	}
	
	action Actor, Actor A_FireProjectileDX(class<Actor> missiletype, double offsetangle = 0, double offsetpitch = 0, double offsetx = 0, double offsety = 0, double offsetz = 0, bool rvel = true)	
	{
		FTranslatedLineTarget t;
		
		if (missiletype) 
		{
			BDPGMQuaternion base = BDPGMQuaternion.createFromAngles(angle,pitch,roll);
			BDPGMQuaternion angl = BDPGMQuaternion.createFromAngles(offsetangle,0,0);
			BDPGMQuaternion ptch = BDPGMQuaternion.createFromAngles(0,offsetpitch,0);
			BDPGMQuaternion rotated = base.multiplyQuat(angl).multiplyQuat(ptch);
			Vector3 dir;
			[dir.x, dir.y, dir.z] = rotated.toAngles();
			quat ofsbase = Quat.FromAngles(angle, pitch, roll);
			Vector3 offset = (offsety, -offsetx, offsetz);
			Vector3 ppos = ofsbase * offset;
			Vector3 ofs = level.Vec3Offset(pos, ppos) - pos;
			ofs.z += player.viewz - pos.z;
			// Temporarily adjusts the pitch
			double saved_player_pitch = pitch;
			pitch = dir.y;
			
			Actor misl, realmisl;
			[misl, realmisl] = SpawnPlayerMissile (missiletype, dir.x, 0, 0, 0, t, false, true);
			pitch = saved_player_pitch;
			
			// automatic handling of seeker missiles
			if (misl)
			{
				if (t.linetarget && !t.unlinked && misl.bSeekerMissile)
					misl.tracer = t.linetarget;
					misl.VelFromAngle(misl.Vel.XY.Length());
					misl.SetOrigin(pos + ofs,false);
				if(rvel)
				{
					misl.vel += player.mo.vel;
				}
			}
			return misl, realmisl;
		}
		return null, null;
	}
	
	action void A_FireParticles(int number = 1, int spread = 12, int offsetx = 0, int offsetz = 0)
	{
		for(int i = number; i > 0; i--)
		{
			A_FireVisualThinker("GunfireParticle", i > number / 2 ? 10 : 15,random(-spread,spread),random(-9,9),offsetx,4,offsetz);
		}
	}
	action void A_FireShieldParticles()
	{
		for(int i = 40; i > 0; i--)
		{
			A_FireVisualThinker("ShieldParticle", i > 40 / 2 ? 2 : 4,random(-4,4),random(-20,20),frandom(-20,20),10,frandom(0,6));
		}
	}
	
	action void A_WeaponRecoil(double offsetpitch, double offsetangle = 0, int recovertime = 2, double recoverspeed = 2)
	{
		let dplr = BDPPlayerPawn(invoker.owner);
		double mod = 1.0;
		
		if(dplr.advancedrecoil)
		{
			if(dplr.bsprinting) mod *= 1.4;
			if(dplr.player.crouchfactor < 0.6) mod *= 0.6;
			if(abs(dplr.player.cmd.forwardmove) > 0 || abs(dplr.player.cmd.sidemove) > 0) mod *= 1.2;
		}
		else
		{
			if(dplr.antiRecoil.x < 15)
			{
				dplr.recoilTics = recovertime;
				dplr.recoilTicGoal = recovertime;
			}
			else
			{
				dplr.recoilTics = 1;
				dplr.recoilTicGoal = recovertime;
			}
		}
		dplr.recoil = (offsetpitch,offsetangle) * mod;
		dplr.antiRecoilSpeed = recoverspeed;
	}
	
	action state A_DualWield()
	{
		if(CountInv(invoker.GetClassName()) > 1)
		{
			GiveInventory(invoker.DualWeapon,1);
			invoker.dualWield = true;
			invoker.initDual = true;
			A_SelectWeapon(invoker.DualWeapon);
			let nextWeapon = BDPWeaponBase(player.PendingWeapon);
			if(nextWeapon)
			{
				nextWeapon.switchingDual = true;
			}
			return resolvestate("InstaDeselect");
		}
		return resolvestate("Ready");
	}
	
	action state A_EndDual()
	{
		A_SelectWeapon(invoker.DualWeapon);
		let nextWeapon = BDPWeaponBase(player.PendingWeapon);
		if(nextWeapon)
		{
			nextWeapon.dualWield = false;
			nextWeapon.switchingDual = true;
		}
		return resolvestate("InstaDeselect");
	}
	
	action state A_CheckIfAmmo(class<Inventory> ammotype, int ammoamount = 1, statelabel label = "NoAmmo")
	{
		If(countinv(ammotype) >= ammoamount || findinventory("PowerSpeed2"))
		{
		Return ResolveState(null);
		}
		Else
		{
		Return resolvestate(label);
		}
	}
	
	
	Action state A_JumpIfMagFull(statelabel label)
	{
		If(invoker.mag >= invoker.MagCapacity)
		{
		Return ResolveState(label);
		}
		Else
		{
		Return resolvestate(null);
		}
	}
	
	action state A_CheckIfMag(int ammoamount = 1, statelabel label = "NoAmmo", bool force = false)
	{
		If(invoker.mag >= ammoamount || (findinventory("PowerSpeed2") && !force))
		{
		Return ResolveState(null);
		}
		Else
		{
		Return resolvestate(label);
		}
	}
	
	action void A_trymeathook(int meathookrange = 256)
	{
	BlockThingsIterator CheckForTargets = BlockThingsIterator.create(Self,meathookrange); //256 can be whatever range around the actor.
Actor CurrentActor; //A pointer to whatever actor the iterator is iterating through.
	If(countinv("meathook") > 0)
	{
	While (CheckForTargets.Next() && countinv("meathook") > 0) 
{
	CurrentActor = CheckForTargets.Thing;
	//If the actor is a monster, has none of the specified item, the caller has a line of sight to the actor, and the actor is within 512 MU, then jump to the see state.
	//Itemname obviously has to be whatever item you want the actor to check that the possible target has none of, and the 512 map unit sight range can be changed to anything else.
	If ((CurrentActor && CurrentActor.bIsMonster && currentactor.bshootable && !currentactor.bfriendly && !currentactor.findinventory("isplayer") && CheckSight(CurrentActor,SF_IGNOREWATERBOUNDARY) && !(currentactor is "ExplosiveBarrel1")) || (currentactor && CheckSight(CurrentActor,SF_IGNOREWATERBOUNDARY) && currentactor.findinventory("isplayer") && currentactor != self))
	{
		target = currentactor;
		If(target)
		{
		
		
		
		vector3 targetpos = LevelLocals.SphericalCoords((pos.x,pos.y,player.viewz),target.pos+(0,0,target.default.height*0.5),(angle,pitch));	
		if (abs(targetpos.x) <= 20 && abs(targetpos.y) <= 20)
			{
  //this will execute only if the Other actor's center is within 25 degrees from the center of the player's screet
	
		//A_customrailgun(8,0,"","",RGF_SILENT|RGF_NOPIERCING,1,20,"bfgpuff",0,0,0,0,1.0,1,"none",-10);
		
		A_spawnprojectile("hook",32);
		A_takeinventory("meathook",1);
		//A_fireprojectile("")
		//A_takeinventory("meathook",1);
		a_startsound("MHKSTRT",193,CHANF_DEFAULT,1,ATTN_NONE);
		}
		//Else A_cleartarget();
		}
		
		
		
		
	}
	If (!target)
	{
	a_startsound("weapons/empty",190,CHANF_DEFAULT,1,ATTN_NONE);
	}
	//A_cleartarget();
}
	}
	
	
	
	
	Else
	{
	a_startsound("weapons/empty",193,CHANF_DEFAULT,1,ATTN_NONE);
	}
	
	
	
	}
	
	
	//action void A_UnmakeLevel(int times=1){BDPWeaponBase.UnmakeLevel(times);}
	action void A_UnmakeLevel(int times=1){
	
		for(int k=0;k<times;k++){
		Bool foundsector;
		Until(foundsector)
		{
			
			sector thissector=level.sectors[random(0,level.sectors.size()-1)];
			Vector3 sectorlocation;
			Sectorlocation.x = thissector.centerspot.x;
			Sectorlocation.y = thissector.centerspot.y;
			sectorlocation.z = thissector.floorplane.ZAtPoint(thissector.centerspot);
			If(LevelLocals.Vec3Diff(invoker.owner.pos, sectorlocation).Length() <= 700)
			{
				foundsector = true;
				int dir=random(-3,3);
				double zatpoint=thissector.floorplane.ZAtPoint(thissector.centerspot);
				thissector.MoveFloor(dir,zatpoint,0,zatpoint>0?-1:1,false);
				dir=random(-3,3);
				zatpoint=thissector.ceilingplane.ZAtPoint(thissector.centerspot);
				thissector.MoveCeiling(dir,zatpoint,0,zatpoint>0?-1:1,false);
				thissector.changelightlevel(random(-random(3,4),3));
				//then maybe add some textures
				textureid shwal;
				switch(random(0,4)){
				case 1:
					shwal=texman.checkfortexture("WALL63_2",texman.type_any);break;
				case 2:
					shwal=texman.checkfortexture("W94_1",texman.type_any);break;
				case 3:
					shwal=texman.checkfortexture("FIREBLU1",texman.type_any);break;
				case 4:
					shwal=texman.checkfortexture("SNAK"..random(7,8).."_1",texman.type_any);break;
				default:
					shwal=texman.checkfortexture("ASHWALL2",texman.type_any);break;
			}
			for(int i=0;i<thissector.lines.size();i++){
				line lnn=thissector.lines[i];
				for(int j=0;j<2;j++){
					if(!lnn.sidedef[j])continue;
					if(!lnn.sidedef[j].GetTexture(side.top))lnn.sidedef[j].SetTexture(side.top,shwal);
					if(!lnn.sidedef[j].GetTexture(side.bottom))lnn.sidedef[j].SetTexture(side.bottom,shwal);
				}
			}
			}
		}
		Foundsector = false;
		}
	}
	
	
	
	Action Bool A_PressedReload()
	{
		If(countinv("reloading") > 0 || player.cmd.buttons & BT_RELOAD)
			Return TRUE;
		Else
			Return FALSE;
	}
	
	
	
	
	action state A_OverlayFadeOut(double value)
		{
		let psp = Player.FindPSprite(OverlayID());
		if (!psp)
			return ResolveState(null);
		A_OverlayFlags(OverlayID(), PSPF_ALPHA|PSPF_FORCEALPHA, true);
		psp.alpha -= value;
		if (psp.alpha <= 0)
			return ResolveState("Null"); //destroy the layer
			return ResolveState(null);
		}
		
	Action state A_AutoReloadMag(int minammo = 1, statelabel label = "Reload", bool force = false)
	{
		//FORCE flag is intended for single shot weapons
		If(invoker.magCapacity > 0 && invoker.mag < minammo && countinv(invoker.ammotype1) >= invoker.magConversion.y && (invoker.owner.getcvar("bdp_autoreload") == true || force == true) && (invoker.readyLeft && invoker.readyRight || !invoker.bDUALWEAPON))
			Return Resolvestate(Label);
		Return Resolvestate(Null);
	}
	
	action void A_Dryfire(string sound = "weapons/empty", bool force = false)
	{
		A_StartSound(sound,3);
		A_AutoReloadMag(1,"Reload",force);
	}
	
	action void A_MagClick(string sound = "weapons/empty")
	{
		double current = invoker.mag;
		double max = invoker.magCapacity / 4;
		if(current <= max && CVar.GetCVar("bd_maggoclicky",player).GetBool() == true)
			A_StartSound(sound,3);
	}
	
	Action state A_WeaponReadyDX(int dxflags = 0, bool kicksprint = true, bool forcereload = false, statelabel fidgetstate = "Fidget")
	{
		let dplr = BDPPlayerPawn(invoker.owner);
		dplr.canLedgeClimb = true;
		DoReadyWeaponToFire(dplr, !(dxflags & WRF_NoPrimary), !(dxflags & WRF_NoSecondary) && invoker.aimMode != 2);
		DoReadyWeaponToSwitch(player, !(dxflags & WRF_NoSwitch));
		if(kicksprint && invoker.aimMode == 0)
			player.WeaponState |= WF_USER1OK;
		if(invoker.readyLeft && invoker.readyRight || !invoker.bDUALWEAPON)
		{
			player.WeaponState |= WF_USER2OK;
			if(!dplr.blockTaunt)
				player.WeaponState |= WF_USER4OK;
			if(dxflags & WRF_ALLOWRELOAD)
			{
				invoker.fidgetState = fidgetstate;
				player.WeaponState |= WF_WEAPONRELOADOK;
			}
			if(!dplr.blockSpecial)
				player.WeaponState |= WF_USER3OK;
			if(invoker.CheckSprint() && kicksprint && resolvestate("Sprint") && invoker.aimMode == 0)
				A_Overlay(50,"Sprint",true);
			else if(player.FindPSprite(50))
			{
				A_ClearOverlays(49,50);
				A_Overlay(49,"SprintEnd");
			}
		}
		if(invoker.aimMode == 2 && invoker.aimTics < 1 && !(player.cmd.buttons & BT_ALTATTACK))
			return resolvestate("AimEnd");
		if(CountInv(invoker.GetClassName()) > 1 && invoker.initDual == 0)
			return resolvestate("SpecialAction");
		return A_AutoReloadMag(1,"Reload",forcereload);
		return resolvestate(null);
	}
	
	action bool JustPressed(int which) // "which" being any BT_* value, mentioned above or not
	{
		return player.cmd.buttons & which && !(player.oldbuttons & which);
	}
	
	action bool JustReleased(int which)
	{
		return !(player.cmd.buttons & which) && player.oldbuttons & which;
	}
	
	action bool LastPressed(int which, int time, bool strict = false)
	{
		let dplr = BDPPlayerPawn(invoker.owner);
		int counter = -1;
		for(int i = -1; i < time - 1; i++)
		{
			if(i == -1 && player.cmd.buttons & which || i > -1 && dplr.oldInputs[i] & which)
			{
				if(!strict || counter == time - 2)
				{
					return true;
				}
				if(strict && counter != i)
				{
					return false;
				}
				counter++;
			}
		}
		return false;
	}
	
	action void MoveSpeed(float pspeed, float psidemove)
	{
		BDPPlayerPawn(self).Speed = pspeed;
		BDPPlayerPawn(self).SideMove1 = psidemove;
		BDPPlayerPawn(self).SideMove2 = psidemove;
	}
	
	//Credit Agent_Ash aka Jekyll Grim Payne and Boondorl
	//Changes ammo type
	action void SetAmmoType1(bool set, Class<Ammo> ammoclass)
	{
		if (set) 
		{
			invoker.ammotype1 = ammoclass;
			invoker.ammo1 = Ammo(FindInventory(ammoclass));
			return;
		}
		invoker.ammo1 = null;
	}
	action void SetAmmoType2(bool set, Class<Ammo> ammoclass)
	{
		if (set)
		{
			invoker.ammotype2 = ammoclass;
			invoker.ammo2 = Ammo(FindInventory(ammoclass));
			return;
		}
		invoker.ammo2 = null;
	}
	
	//Credit Mikk0451
	//Changes ammo icon only
	action void ChangeWeaponIcon(String Icon)
	{
		invoker.althudicon = texman.CheckForTexture(Icon, TexMan.Type_Any);
	}
	action void ChangeAmmoIcon1(String AmmoIcon)
	{
		(findInventory(invoker.ammo1.GetClassName())).icon = texman.CheckForTexture(AmmoIcon, TexMan.Type_Any);
	}
	action void ChangeAmmoIcon2(String AmmoIcon)
	{
		(findInventory(invoker.ammo2.GetClassName())).icon = texman.CheckForTexture(AmmoIcon, TexMan.Type_Any);
	}
	action void ChangeAmmoIcon3(String AmmoIcon)
	{
		(findInventory(invoker.AmmoType3)).icon = texman.CheckForTexture(AmmoIcon, TexMan.Type_Any);
	}
	
	action void LedgeReach(float HeightDecrease)
	{
		let dplr = BDPPlayerPawn(self);
		dplr.LedgeHeightMax = (dplr.LedgeHeight - Height * HeightDecrease * 1.0f);
		A_Stop();
		SetOrigin((Pos.X, Pos.Y, dplr.LedgeHeightMax), True);
	}
	//by Emerald
	action void A_SetCVAR(string cvartoset, int valuetoset)
	{
		CVar.GetCVar(cvartoset, Player).SetInt(valuetoset);
	}
	
	Bool CheckSprint()
	{
		let dplr = BDPPlayerPawn(owner);
		If(!dplr || !dplr.bsprinting)
		{
			Return False;
		}
		Else
		{
			Return True;
		}
	}
	
	action void A_AlertMonstersDX(double maxdist = 0, int flags = 0)
	{
		A_alertmonsters(maxdist,flags);
		
		if(invoker.owner.bshadow)
		{
			invoker.owner.giveinventory("moveblurspheretarget",1);
		}
	}
	
	action void A_SemiFlag(bool secondary = false)
	{
		let dplr = BDPPlayerPawn(invoker.owner);
		if(secondary)
		{
			dplr.blockAltfire = true;
			invoker.semiautofired = 2;
		}
		else
		{
			dplr.blockFire = true;
			invoker.semiautofired = 1;
		}
	}
	
	action state A_SemiRefire(statelabel refirelabel = "Fire")
	{
		invoker.semiautofired = 0;
		if(invoker.semiclear)
		{
			invoker.semiclear = false;
			return resolvestate(refirelabel);
		}
		return resolvestate(null);
	}
	
	action state A_RefireDX(statelabel refirelabel = "Fire", bool altfire = false)
	{
		if((!altfire && player.cmd.buttons & BT_ATTACK) || (altfire && player.cmd.buttons & BT_ALTATTACK))
		{
			player.refire++;
			return resolvestate(refirelabel);
		}
		else
		{
			player.refire = 0;
			return resolvestate(null);
		}
	}
	
	action void A_SetSprites(string sprite, int layer = -1)
	{
		let psp = player.FindPSprite(layer == -1 ? OverlayID() : layer);
		if(psp)
		{
			psp.sprite = GetSpriteIndex(sprite);
		}
	}
	
	action void A_SetFrame(int frame, int layer = 1)
	{
		let psp = player.FindPSprite(layer);
		if(psp)
		{
			psp.frame = frame;
		}
	}
	
	
	void StainSprites(string sprite, int layer = 1)
	{
		if(owner.player && bloodstain > 0)
		{
			let psp = owner.player.FindPSprite(layer);
			if(psp && TexMan.GetName(psp.curstate.GetSpriteTexture(0)).Mid(1,3) == sprite)
			{
				psp.sprite = GetSpriteIndex(bloodStain..sprite);
			}
		}
	}
	
	virtual void DoSpriteStain()
	{
		StainSprites("L1M");
		StainSprites("UCK");
	}
	
	action void A_FirePiercingBullet(int damage, class<Actor> pufftype = "BulletPuff", double spread_xy = 0, double spread_z = 0, int spawnofs_xy = 0, double spawnofs_z = 0, double range = 8192)
	{
	
		spread_xy = spread_xy * Random2[crailgun]() / 255.;
		spread_z = spread_z * Random2[crailgun]() / 255.;
		
		FRailParams p;
		p.damage = damage;
		p.offset_xy = 0;
		p.offset_z = 0;
		p.color1 = -1;
		p.color2 = -1;
		p.maxdiff = 0;
		p.flags = RGF_SILENT | RGF_NORANDOMPUFFZ;
		p.puff = pufftype;
		p.angleoffset = spread_xy;
		p.pitchoffset = spread_z;
		p.distance = range;
		p.duration = 0;
		p.sparsity = 1.0;
		p.drift = 0;
		p.spawnclass = null;
		p.SpiralOffset = 0;
		p.limit = 0;
		self.RailAttack(p);
		//Railattack's puff spawning is fucked so we're faking it with a linetrace
		FLineTraceData lasersight;
		LineTrace(angle + spread_xy, range, pitch + spread_z, TRF_THRUACTORS, offsetz: player.viewz - pos.z, data: lasersight);
		vector3 targetpos = lasersight.HitLocation;
		double ricochetangle;
		if (lasersight.HitType == TRACE_HitWall)
			{
			//	A_logint(wallangle.lineside);
			   ricochetangle = atan2(lasersight.hitline.delta.y, lasersight.hitline.delta.x) - 90;
			vector2 wallnormal = (-lasersight.HitLine.delta.y,lasersight.HitLine.delta.x).unit();
				//We need to create consistent behaviour for either line side
				If (lasersight.lineside == 1)
				{
					RicochetAngle = (ricochetangle - 180);
					
					targetpos += (wallnormal * 6);
				}
				else
				{	
					rotatevector(wallnormal,180);
					targetpos += (wallnormal * -6);
					
				}
				
			}
		Else
		{
			ricochetangle = angle + 180;
		}
		let ricochet = Spawn("ricochet",targetpos);
		If(ricochet)
		{	
			//Doing this from the ricochet to avoid recalculating offsets
			If(lasersight.HitType == TRACE_HitWall)
			{
				ricochet.angle = ricochetangle + 180;
				ricochet.a_spraydecal("BulletDecalNew1",172,(0,0,-1));
			}
			
			ricochet.angle = ricochetangle;
		}
		double saved_player_pitch = self.Pitch;
		self.Pitch += spread_z;
		double ang = self.Angle - 90;
		Vector2 ofs = AngleToVector(ang, spawnofs_xy);
		SpawnPlayerMissile("decorativetracer",angle + spread_xy,ofs.x,ofs.y,spawnofs_z);
		self.Pitch = saved_player_pitch;
	}
	
	override void DoEffect() 
	{
		super.DoEffect();
		
		let player = owner.player;
		let dplr = BDPPlayerPawn(owner);
		//Flag that forces this weapon to be selected
		//Used for things that can't be switched off from
		//Like explosive barrels
		If(owner && forceselect)
		{
			owner.A_selectweapon(self.getclass());
		}
		If(player && player.readyweapon is self.getclass())
		{
			if(!(player.readyweapon is "BDPFist"))
			{
				let fists = BDPWeaponBase(owner.FindInventory("BDPFist"));
				if(owner.CountInv("PowerBloodOnVisor") > 0)
					fists.bloodStain = 1;
				if(owner.CountInv("PowerBlueBloodOnVisor") > 0)
					fists.bloodStain = 2;
				if(owner.CountInv("PowerGreenBloodOnVisor") > 0)
					fists.bloodStain = 3;
			}
			if(self.bBLOODSTAIN)
			{
				if(owner.CountInv("PowerBloodOnVisor") > 0)
					bloodStain = 1;
				if(owner.CountInv("PowerBlueBloodOnVisor") > 0)
					bloodStain = 2;
				if(owner.CountInv("PowerGreenBloodOnVisor") > 0)
					bloodStain = 3;
			}
			DoSpriteStain();
			owner.TakeInventory("PowerBloodOnVisor",1);
			owner.TakeInventory("PowerBlueBloodOnVisor",1);
			owner.TakeInventory("PowerGreenBloodOnVisor",1);
			
			if(player.cmd.buttons & BT_ATTACK && semiautofired == 1 && !dplr.blockFire || player.cmd.buttons & BT_ALTATTACK && semiautofired == 2 && !dplr.blockAltFire)
			{
				semiclear = true;
			}
			
			if(aimTics > 0 && aimMode > 0)
			{
				if(player.cmd.buttons & BT_ALTATTACK)
					aimTics--;
				else
					aimMode = 1;
			}
			
			If(!owner.findinventory("grabbermodifier"))
			{
				owner.giveinventory("grabbermodifier",1);
			}
			
			bool autogrenadeswitch;
			
			If(owner.countinv("nadetype") == 0 && owner.countinv("ammofraggrenade") == 0 && owner.countinv("ammopipebomb"))
			{
				autogrenadeswitch = true;
			}
			If(owner.countinv("nadetype") == 1 && owner.countinv("AmmoPipeBomb") == 0 && owner.countinv("ammofraggrenade") >= 1)
			{
				autogrenadeswitch = true;
			}
			
			If(owner.countinv("ammofraggrenade") > 0 && owner.countinv("ammopipebomb") < 1 || owner.countinv("ammofraggrenade") < 1 && owner.countinv("ammopipebomb") > 0)
			Owner.takeinventory("grenadeswapping",1);
			
			If(owner.findinventory("grenadeswapping") || autogrenadeswitch)
			{
			
	

				if(owner.CountInv("NadeType") == 0)
				{
					owner.giveinventory("nadetype",1);
					If(!autogrenadeswitch && owner.countinv("ammopipebomb") > 0)
					owner.A_startSound ("PIPESEL",92);
					//owner.A_Print("\cnFreeze grenades selected.",2);
				}
				Else
				{
					owner.takeinventory("nadetype",666);
					If(!autogrenadeswitch && owner.countinv("ammofraggrenade") > 0)
					owner.A_startSound ("GRNPIN",92);
					//owner.A_Print("Cluster grenades selected.",2);
				}
				
			}
			Owner.takeinventory("grenadeswapping",1);
		
			
			If(CheckSprint())
			{
				
				If(owner.findinventory("istacticalclass") && dplr)
				{
					If(owner.findinventory("powerstrength") || owner.findinventory("powerboost"))
					{
						if (level.time % 2 == 0)
						{
							dplr.stamina += 2;
						}
					}
					Else
					{
						if (level.time % 2 == 0)
						{
							dplr.stamina += 3;
						}
					}
					
				}
				if(aimMode > 0)
				{
					BobRangeX = 0.3;
					BobRangeY = 0.4;
				}
				else
				{
					BobRangeX = 0.6;
					BobRangeY = 0.8;
				}
				BobSpeed = 2.9;
			}
			else
			{
				if(aimMode > 0)
				{
					BobRangeX = 0.1;
					BobRangeY = 0.2;
				}
				else
				{
					BobRangeX = 0.2;
					BobRangeY = 0.4;
				}
				BobSpeed = 2.1;
			}
  
 
  
			if(GetCvar("smooth_mouse") == true ) 
			{
				if (player && player.readyweapon) {
				player.WeaponState |= SPF_INTERPOLATE;
				}
			}
  
  //Hacky fix for weapon timers
			If(owner.countinv("cyberdemonrockets") == 1 || owner.countinv("spiderchainguntimer") == 1)
			{
				guntimertics = (guntimertics + 1);
		
				If(guntimertics > 35)
				{
					owner.takeinventory("cyberdemonrockets",666);
					owner.takeinventory("spiderchainguntimer",666);
				}
			}
			Else
			{
				guntimertics = 0;
			}
	
			//No more death overlaysssss
			If(owner.health < 1)
			{
				owner.A_clearoverlays(-700,30,false);
			}
		
			If(gunslingertics < 175)
			{
				Gunslingertics = 175;
			}
			//Console.printf(self.getclassname());
		}
		Else
		{
			If(gunslingertics > 0)
			{
				Gunslingertics--;
			}
			If(gunslingertics == 0 && !gunslingereligible && gunslinger && mag <= magcapacity)
			{
				Gunslingereligible = true;
				owner.A_startsound("GUNSLNG",424,0,1);
			}
			If(gunslingertics == 0 && !gunslingereligible && gunslinger && gunslinger2)
			{
				Gunslingereligible = true;
				owner.A_startsound("GUNSLNG",424,0,1);
			}
		}
  
}
	
	Override void attachtoowner(Actor other)
		{
			Gunslingereligible = true;
			Super.attachtoowner(other);
		}
	
	
	States
	{
	//Fallback weapon states
	Grenade: //30
		TNT1 A 30;
		Goto Ready;
	NoAmmo:
		TNT1 A 0 A_DryFire();
		TNT1 A 0
		{
			if(invoker.aimMode > 0)
			{
				return resolvestate("Aim");
			}
			return resolvestate("Ready");
		}
		Goto Ready;
	Select:
	Deselect:
	Fire:
	Ready:
		TNT1 A 1 A_Jump(256, "Ready");
		Loop;
	InstaDeselect:
		TNT1 A 0 A_Lower();
		Wait;
	LedgeClimb:
		TNT1 A 0 
		{
			if(invoker.clearoverlays)
			{
				A_clearoverlays(-30,30);
			}
			A_clearoverlays(49,50);
			A_WeaponOffset(0,32);
			A_Stop();
			A_ZoomFactor(1.0);
			SetPlayerProperty(0,1,PROP_TOTALLYFROZEN);
			A_StartSound("ledgeclimb",5);
		}
		CL1M ABC 1 
		{
			let dplr = BDPPlayerPawn(self);
			
			if(Pos.Z < (dplr.LedgeHeight - Height * 0.78f))
			{
				pitch -= pitch/2;
				Vel = Vel.Length() ? (0, 0, dplr.velz) : (0, 0, 0);
				//dplr.velz--;
			}
			else if(Pos.Z < (dplr.LedgeHeight - Height * 0.76f))
			{
				LedgeReach(0.751);
				return ResolveState("LedgeReach");
			}
			return ResolveState(null);
		}
	LedgeReach:
		CL1M D 1
		{
			let dplr = BDPPlayerPawn(self);
			//if(Pos.Z >= (dplr.LedgeHeight - Height * 0.78f) && Pos.Z < (dplr.LedgeHeight - Height * 0.76f))
			if(Pos.Z >= (dplr.LedgeHeight - Height * 0.78f))
			{
				pitch -= pitch/2;
				GiveInventory("Grabbing_A_Ledge", 1);
				LedgeReach(0.751);
			}
			else if(Pos.Z < (dplr.LedgeHeight - Height * 0.78f))
			{
				Vel = Vel.Length() ? (0, 0, dplr.velz) : (0, 0, 0);
			}
		}
		TNT1 A 0 A_JumpIf(CountInv("Grabbing_A_Ledge")==1, 1);
		Goto LedgeReach;
		CL1M E 1
		{
			let dplr = BDPPlayerPawn(self);
				
			dplr.velz = 3.6;
			pitch = 0;
			LedgeReach(0.751);
			A_StopSound(CHAN_WEAPON);
			dplr.LedgeAngle = Angle;
			dplr.LedgeCheck = False;
			dplr.LedgeGrabbed = True;
		}
		CL1M F 1
		{
			pitch -= 0.5;
			Vel = Vel.Length() ? (0, 0, 0.5) : (0, 0, 0);
		}
		CL1M G 1
		{
			let dplr = BDPPlayerPawn(self);
			pitch += 3;
			Vel = Vel.Length() ? (0, 0, dplr.velz) : (0, 0, 0);
		}
		CL1M HI 1
		{
			let dplr = BDPPlayerPawn(self);
			pitch += 4;
			Vel = Vel.Length() ? (0, 0, dplr.velz) : (0, 0, 0);
		}
	FinishClimb:
		TNT1 A 0 A_GunFlash("LedgeGrabFlash");
		CL1M JK 1
		{
			let dplr = BDPPlayerPawn(self);
			
			dplr.velz = 3.6;
			pitch -= 3;
			Vel = Vel.Length() ? (0, 0, dplr.velz) : (0, 0, 0);
		}
		CL1M LM 1 {pitch -= 2;}
		TNT1 AA 1
		{
			pitch -= pitch/2;
			A_WeaponReady(WRF_NOSWITCH);
		}
		TNT1 A 0 {pitch = 0;}
		TNT1 A 0 SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
		TNT1 A 0 TakeInventory("Grabbing_A_Ledge", 1);
		TNT1 A 0 A_Jump(256,"Select");
		Goto Ready;
	InitWeaponState:
		//TNT1 A 1 Emma you fucking idiot
		TNT1 A 0
		{
			A_zoomfactor(1.0);
			If(!(invoker is "Explosivebarrelweapon"))
			{
				Invoker.owner.takeinventory("explosivebarrelweapon",1);
			}
			invoker.aimMode = 0;
			invoker.semiautofired = 0;
			invoker.semiclear = false;
			
			A_SetCrosshair(-1);
			a_weaponvoiceline();
			let psp = Player.FindPSprite(OverlayID()); //get pointer to current sprite layer;
			if (psp)
				psp.y = WEAPONTOP; //set offset immediately to the fully raised position;
			if(invoker.dualWeapon && countinv(invoker.GetClassName()) > 1 && invoker.dualWield == 1 && GetCVar("bd_smartdualwield") == 0)
			{
				A_SelectWeapon(invoker.dualWeapon);
				return resolvestate("InstaDeselect");
			}
			if(invoker.dualWeapon && invoker.switchingDual == true)
			{
				invoker.switchingDual = false;
				return resolvestate("SelectFromDual");
			}
			return resolvestate("Select");
		}
		Loop;
	Reload:
		#### # 1
		{
			if((invoker.mag < invoker.magCapacity || invoker.bDUALWEAPON && DualMag() < invoker.magCapacity) && CountInv(invoker.ammotype1) >= invoker.magConversion.y)
			{
				A_ClearOverlays(49,50);
				return resolvestate("DoReload");
			}
			else if(resolvestate(invoker.fidgetState) && invoker.aimMode == 0 && (invoker.fidgetState != "Fidget" || LastPressed(BT_RELOAD,7,true)))
			{
				return resolvestate(invoker.fidgetState);
			}
			return resolvestate(null);
		}
		TNT1 A 0 A_JumpIf(invoker.aimMode > 0,"Aim");
		Goto Ready;
	User4:
		#### # 1
		{
			if(invoker.handedness == 2 && !resolvestate("Taunt"))
			{
				return resolvestate("TauntNone");
			}
			else
			{
				A_Overlay(69,"TauntAction");
			}
			return resolvestate(null);
		}
		TNT1 A 0 {return resolvestate("Taunt");}
		Goto Ready;
	TauntAction:
		TNT1 A 4;
		TNT1 A 0 
		{
			If(random(1,200) == 7)
			{
				A_startsound("FUCK5",455);
			}
			Else
			{
				A_startsound("FUCK",455);
			}
			A_FireProjectile("Taunter", 0, 0, -1, 0);
			A_FireProjectile("Taunter", -9, 0, -1, 0);
			A_FireProjectile("Taunter", 9, 0, -1, 0);
		}
		TNT1 A 0 A_jumpif(invoker.handedness == 1, "Finishtauntleft");
		FUCK ABCD 1 A_AlertMonsters();
		FUCK E 1;
		FUCK F 12;
		FUCK EDCBA 1;
		TNT1 A 4 A_Takeinventory("Taunting",1);
		TNT1 A 0
		{
			let dplr = BDPPlayerPawn(invoker.owner);
			dplr.blockTaunt = false;
		}
		Stop;
	FinishTauntLeft:
		FUCK GHIJ 1 A_AlertMonsters();
		FUCK K 1;
		FUCK L 12;
		FUCK KJIHG 1;
		TNT1 A 4 A_Takeinventory("Taunting",1);
		TNT1 A 0
		{
			let dplr = BDPPlayerPawn(invoker.owner);
			dplr.blockTaunt = false;
		}
		Stop;
	BlanKTaunt:
		TNT1 A 26;
		Goto Ready;
	TauntNone:
		TNT1 A 26
		{
			If(random(1,200) == 7)
			{
				A_startsound("FUCK5",455);
			}
			Else
			{
				A_startsound("FUCK",455);
			}
			A_FireProjectile("Taunter", 0, 0, -1, 0);
			A_FireProjectile("Taunter", -9, 0, -1, 0);
			A_FireProjectile("Taunter", 9, 0, -1, 0);
		}
		TNT1 A 0
		{
			let dplr = BDPPlayerPawn(invoker.owner);
			dplr.blockTaunt = false;
		}
		Goto Ready;
	User3:
		#### # 1
		{
			let dplr = BDPPlayerPawn(invoker.owner);
			dplr.blockSpecial = true;
			if(invoker.dualWeapon && CountInv(invoker.GetClass()) <  invoker.MaxAmount)
				A_Print("You must have two "..invoker.GetTag().."s to Dual wield!",3);
			else if(resolvestate("SpecialAction"));
			{
				A_ClearOverlays(49,50);
				return resolvestate("SpecialAction");
			}
			return resolvestate(null);
		}
		Goto Ready;
	User2:
		#### # 1
		{
			if(CountInv("AmmoFragGrenade") > 0 || CountInv("AmmoPipeBomb") > 0 || CountInv("PowerSpeed2") > 0)
			{
				let dplr = BDPPlayerPawn(invoker.owner);
				dplr.canLedgeClimb = false;
				A_ClearOverlays(49,50);
				if(CountInv("NadeType") == 1)
					A_Overlay(90,"TossPipebomb");
				else
					A_Overlay(90,"TossGrenade");
				return resolvestate("Grenade");
			}
			else
			{
				A_Print("Out of grenades");
				return resolvestate(null);
			}
		}
		Goto Ready;
	TossGrenade:
		TNT1 A 5;
		GRTH ABCDEF 1;
		TNT1 A 0 A_StartSound ("GRNPIN");
		GRTH FGHIJK 1;
		TNT1 A 2;
		TNT1 A 0 A_StartSound ("CS16uwu");
		TNT1 A 0 A_Jump(2,2);
		TNT1 A 0 A_StartSound ("GRNTOSS");
		GRTH LM 1;
		TNT1 A 0
		{
			A_TakeAmmo("AmmoFragGrenade", 1);
			A_FireProjectile("HandGrenade", 0, 0, 0, 0, 0, 0);
			A_QuadSound();
		}
		GRTH NOP 1;
		TNT1 A 5;
		Stop;
	TossPipebomb:
		TNT1 A 5;
		TNT1 A 0 A_startsound("MineArm",2);
		DKPB PQRSTUFGHI 1;
		TNT1 A 0 
		{
			A_FireProjectile("PipebombThrownQuickTossed",0,0,0,0);
			A_StartSound("DukeThrw");
			A_QuadSound();
		}
		BFGN A 0 A_TakeAmmo("AmmoPipeBomb", 1);
		DKPB JKKKLLMNO 1;
		TNT1 A 5;
		Stop;
	BloodSplashRed:
		TNT1 A 1
		{
			a_overlaypivotalign(overlayid(),PSPA_CENTER,PSPA_CENTER);
			a_overlayflags(OverlayID(),PSPF_ADDWEAPON | PSPF_ADDBOB,false);
			a_overlayoffset(OverlayID(),random(-150,150),random(0,0));
			If(random(0,1) == 1)
			{
				a_overlayflags(OverlayID(),PSPF_FLIP,false);
			}
			Else
			{
				a_overlayflags(OverlayID(),PSPF_FLIP,true);
			}
			a_overlayrotate(Overlayid(),90 * random(0,3));
			A_overlayscale(overlayid(),frandom(0.3,1.5));
		}
		SBDR A random(10,30);
		SBDR AAAAAAAAAAAAAAAAAAAAA 1 A_overlayfadeout(0.05); 
		Stop;
	BloodSplashGreen:
	TNT1 A 1
		{
			a_overlaypivotalign(overlayid(),PSPA_CENTER,PSPA_CENTER);
			a_overlayflags(OverlayID(),PSPF_ADDWEAPON | PSPF_ADDBOB,false);
			a_overlayoffset(OverlayID(),random(-150,150),random(0,0));
			If(random(0,1) == 1)
			{
				a_overlayflags(OverlayID(),PSPF_FLIP,false);
			}
			Else
			{
				a_overlayflags(OverlayID(),PSPF_FLIP,true);
			}
			a_overlayrotate(Overlayid(),90 * random(0,3));
			A_overlayscale(overlayid(),frandom(0.3,1.5));
		}
		SBDG A random(10,30);
		SBDG AAAAAAAAAAAAAAAAAAAAA 1 A_overlayfadeout(0.05); 
		Stop;
	BloodSplashBlue:
		TNT1 A 1
		{
			a_overlaypivotalign(overlayid(),PSPA_CENTER,PSPA_CENTER);
			a_overlayflags(OverlayID(),PSPF_ADDWEAPON | PSPF_ADDBOB,false);
			a_overlayoffset(OverlayID(),random(-150,150),random(0,0));
			If(random(0,1) == 1)
			{
				a_overlayflags(OverlayID(),PSPF_FLIP,false);
			}
			Else
			{
				a_overlayflags(OverlayID(),PSPF_FLIP,true);
			}
			a_overlayrotate(Overlayid(),90 * random(0,3));
			A_overlayscale(overlayid(),frandom(0.3,1.5));
		}
		SBDB A random(10,30);
		SBDB AAAAAAAAAAAAAAAAAAAAA 1 A_overlayfadeout(0.05); 
		Stop;
	}
}


CLASS TemporaryWeapon : BDPWeaponBase
{
	bool hasexploded;
	Override void doeffect()
	{
		if (level.time % 35 == 0 && owner.player.readyweapon is self.getclass()) {
			if (owner.countinv(ammotype1) > 0)
			{
				
					owner.Takeinventory(ammotype1,1);
					
			}
			
		}
		Super.doeffect();
	}
	
	States
	{
		GunExplodes:
		TNT1 A 0 A_overlay(5,"GunExplodeOverlay");
		TNT1 A 6;
		NULL A 0 A_FireProjectile("TempGunExplosionSpawner", 0, 0, 0, 0, -2);
		NULL A 0 A_WeaponOffset(0,32);
		
		//CYBF X 70
		2YBF ABCDD 1;
		2YBF E 12;
		2YBF EFGHIJJ 1;
		2YBF K 8;
		2YBF LMNOPQ 1;
		TNT1 A 2;
	//	NULL A 0 A_SelectWeapon("Melee_Attacks")
		TNT1 A 0 {invoker.depleteordestroy();}
	
	}
}



CLASS BloodSplasher : Actor
{
	Default
	{
	
	damagefactor "Trample", 0.0;
	DamageType "Blood";
	Health 1;
	Radius 1;
	Height 1;
	Mass 1;
	+NOCLIP;
	+NOGRAVITY;
	+ACTIVATEMCROSS;
	+WINDTHRUST;
	+NODAMAGETHRUST;
	+PIERCEARMOR;
	+BLOODLESSIMPACT;
	DeathSound "None";
	}
	States
	{
	Spawn:
		TNT1 A 0 A_ClearTarget();
		TNT1 A 0 A_Look();
		TNT1 A 0 A_RadiusGive("BloodSplasherZ", 96, RGF_PLAYERS, 1);
		TNT1 A 0 A_JumpIfInTargetInventory("BloodSplasherz", 1, "Blood");
		 Stop;

	Blood:
		TNT1 A 0 A_TakeFromTarget("BloodSplasherz", 1);
		TNT1 A 0 {A_GiveToTarget("BloodOnVisor",1);A_TakeFromTarget("PowerBlueBloodOnVisor",1);A_TakeFromTarget("PowerGreenBloodOnVisor",1);}
		//TNT1 A 0 A_GiveToTarget("BloodOnVisor", 1)
		TNT1 A 0 A_GiveToTarget("MeatAmmo", 1);
		TNT1 A 0 A_JumpIf(GetCvar("bd_ScreenFX")>=1, "BloodSplashStop");
	TNT1 A 0
	{
		If(target && target.player)
			{
			bool layerfound;
			int i = 110;
			
			until (layerfound)
				{
				
				If(!target.player.findpsprite(i))
					{
					
					target.player.SetPSprite(i,target.player.ReadyWeapon.FindState("bloodsplashred"));
					//target.a_overlayoffset(i,random(-180,180),random(-90,120));
					layerfound = true;
					
					}
				i++;
				}
			
			}
	}
		 
	BloodSplashStop:
		TNT1 A 1;
		//TNT1 A 0 A_Explode(3,250)
		//TNT1 A 0 A_Explode(3,120)
		Stop;
		
	}
}

CLASS TinyBloodSplasher : BloodSplasher
{

	States
	{
	Spawn:
		TNT1 A 0 A_ClearTarget();
		TNT1 A 0 A_Look();
		TNT1 A 0 A_JumpIf(GetCvar("bd_BloodTrail")==1, "BloodSplashStop");
		TNT1 A 0 A_RadiusGive("BloodSplasherZ", 48, RGF_PLAYERS, 1);
		TNT1 A 0 A_JumpIfInTargetInventory("BloodSplasherz", 1, "Blood");
		TNT1 A 1;
		 Stop;
		
	}
}

CLASS SuperBloodSplasher : BloodSplasher
{

	States
	{
	Spawn:
		TNT1 A 0 A_ClearTarget();
		TNT1 A 0 A_Look();
		TNT1 A 0 A_RadiusGive("BloodSplasherZ", 96, RGF_PLAYERS, 1);
		TNT1 A 0 A_JumpIfInTargetInventory("BloodSplasherz", 1, "Blood");
		Stop;
	}
}





// Blue Blood
CLASS BlueBloodSplasher : Bloodsplasher
{

	States
	{
	Spawn:
		TNT1 A 0 A_ClearTarget();
		TNT1 A 0 A_Look();
		TNT1 A 0 A_RadiusGive("BloodSplasherBlueBlood", 96, RGF_PLAYERS, 1);
		TNT1 A 0 A_JumpIfInTargetInventory("BloodSplasherBlueBlood", 1, "BlueBlood");
		Stop;

	BlueBlood:
		TNT1 A 0 A_TakeFromTarget("BloodSplasherBlueBlood", 1);
		TNT1 A 0 {A_TakeFromTarget("PowerBloodOnVisor",1);A_GiveToTarget("BlueBloodOnVisor",1);A_TakeFromTarget("PowerGreenBloodOnVisor",1);}
		//TNT1 A 0 A_GiveToTarget("BlueBloodOnVisor", 1)
		TNT1 A 0 A_JumpIf(GetCvar("bd_ScreenFX")>=1, "BlueBloodSplashStop");
	TNT1 A 0
	{
		If(target && target.player)
			{
			bool layerfound;
			int i = 110;
			
			until (layerfound)
				{
				
				If(!target.player.findpsprite(i))
					{
					
					target.player.SetPSprite(i,target.player.ReadyWeapon.FindState("bloodsplashblue"));
					//target.a_overlayoffset(i,random(-180,180),random(-90,120));
					layerfound = true;
					
					}
				i++;
				}
			
			}
	}
		
		 
	BlueBloodSplashStop:
		TNT1 A 1;
		//TNT1 A 0 A_Explode(3,250)
		//TNT1 A 0 A_Explode(3,120)
		Stop;
		
	}
}

CLASS BlueSuperBloodSplasher : BlueBloodSplasher
{

	States
	{
	Spawn:
		TNT1 A 0 A_ClearTarget();
		TNT1 A 0 A_Look();
		TNT1 A 0 A_RadiusGive("BloodSplasherBlueBlood", 96, RGF_PLAYERS, 1);
		TNT1 A 0 A_JumpIfInTargetInventory("BloodSplasherBlueBlood", 1, "BlueBlood");
		Stop;
	}
}




// Green Blood
CLASS GreenBloodSplasher : bloodsplasher
{

	States
	{
	Spawn:
		TNT1 A 0 A_ClearTarget();
		TNT1 A 0 A_Look();
		TNT1 A 0 A_RadiusGive("BloodSplasherGreenBlood", 96, RGF_PLAYERS, 1);
		TNT1 A 0 A_JumpIfInTargetInventory("BloodSplasherGreenBlood", 1, "GreenBlood");
		Stop;

	GreenBlood:
		TNT1 A 0 A_TakeFromTarget("BloodSplasherGreenBlood", 1);
		TNT1 A 0 {A_TakeFromTarget("PowerBloodOnVisor",1);A_TakeFromTarget("PowerBlueBloodOnVisor",1);A_GiveToTarget("GreenBloodOnVisor",1);}
	//	TNT1 A 0 A_GiveToTarget("GreenBloodOnVisor", 1)
		TNT1 A 0 A_JumpIf(GetCvar("bd_ScreenFX")>=1, "GreenBloodSplashStop");
	TNT1 A 0
	{
		If(target && target.player)
			{
			bool layerfound;
			int i = 110;
			
			until (layerfound)
				{
				
				If(!target.player.findpsprite(i))
					{
					
					target.player.SetPSprite(i,target.player.ReadyWeapon.FindState("bloodsplashgreen"));
					//target.a_overlayoffset(i,random(-180,180),random(-90,120));
					layerfound = true;
					
					}
				i++;
				}
			
			}
	}
		
		 
	GreenBloodSplashStop:
		TNT1 A 1;
		//TNT1 A 0 A_Explode(3,250)
		//TNT1 A 0 A_Explode(3,120)
		Stop;
	}
}

CLASS GreenSuperBloodSplasher : GreenBloodSplasher
{

	States
	{
	Spawn:
		TNT1 A 0 A_ClearTarget();
		TNT1 A 0 A_Look();
		TNT1 A 0 A_RadiusGive("BloodSplasherGreenBlood", 96, RGF_PLAYERS, 1);
		TNT1 A 0 A_JumpIfInTargetInventory("BloodSplasherGreenBlood", 1, "GreenBlood");
		Stop;
	}
}

class BDP_GunLight : DynamicLight 
{

	int alivetime; 
	property alivetime : alivetime;
	default {
		DynamicLight.Type "Point";
		+DYNAMICLIGHT.ATTENUATE;
		+DYNAMICLIGHT.SPOT
		self.alivetime 2;
	}
	override void Tick() {
		super.Tick();
		alivetime--;
		If(alivetime <= 0)
		{
			Destroy();
		}
	}

	
}
